<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>OpenTelemetry</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1_Concept_Data_Sources.html"><strong aria-hidden="true">1.</strong> Concept - Data Source</a></li><li class="chapter-item expanded "><a href="2_Concepts_Instrumenting.html"><strong aria-hidden="true">2.</strong> Concept - Instrumenting</a></li><li class="chapter-item expanded "><a href="3_Concept_Instrumenting_Libraries.html"><strong aria-hidden="true">3.</strong> Concept - Instrumenting Libraries</a></li><li class="chapter-item expanded "><a href="4_Concept_Data_Collection.html"><strong aria-hidden="true">4.</strong> Concept - Data Collection</a></li><li class="chapter-item expanded "><a href="5_Concept_Distributions.html"><strong aria-hidden="true">5.</strong> Concept - Distributions</a></li><li class="chapter-item expanded "><a href="6_Collector_Getting_Started.html"><strong aria-hidden="true">6.</strong> Collector - Getting Started</a></li><li class="chapter-item expanded "><a href="7_Metrics_API.html"><strong aria-hidden="true">7.</strong> Metrics - API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">OpenTelemetry</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#1-concept---data-sources" id="1-concept---data-sources">1. Concept - Data Sources</a></h1>
<p><strong>OpenTelemetry</strong>  支持下面各种不同的数据源。</p>
<h2><a class="header" href="#traces" id="traces">Traces</a></h2>
<p><code>Traces</code> 用于跟踪单个请求的处理进度，每个 <code>Trace</code> 会在应用的每个服务中进行处理，而请求则可能是通过用户侧或是应用自身发起的。分布式的跟踪一般由跨进程、网络及各种安全边界的调用形式来呈现。每个 <code>Trace</code> 中的工作单元称为 <code>Span</code>；一个 <code>Trace</code> 是一颗由 <code>Span</code> 组成的树。<code>Span</code> 表示一个请求触发了一个独立的服务或组件在整个系统中的流转信息，每个 <code>Span</code> 都会有一个 <code>Context</code>，其中包含能表示当前请求的全局唯一的标识符。同时 <code>Span</code> 还能够提供 <code>Request</code>、<code>Error</code>、<code>Duration</code> <em>(RED)</em> 这些能用来帮助调试可用性跟进行性能检测使用的指标 <code>Metrics</code> 。</p>
<p><code>Trace</code> 会包含一个根级别的用来表示端对端之间请求整体延时信息的  <code>Span</code> ，你可以把他当成一个逻辑性的操作，比如网页应用点击了一个按钮来将某个产品加入购物车，这个根 <code>Span</code> 就是用来确认中断用户在点击按钮到最后整个操作成功或失败到展示给用户所消耗的时间 <em>(即要么商品成功加入购物车要么出错)</em>。一个 <code>Trace</code> 会由一个根 <code>Span</code> 跟若干个子 <code>Span</code> 来组成，他们同时也表示了对应操作在整个请求过程中的位置。每个 <code>Span</code> 包含了当前操作的元数据，比如名称、起止时间、属性、事件跟状态等。</p>
<p>为了在 <code>OpenTelemetry</code> 中创建跟管理 <code>Span</code>，<code>OpenTelemetry API</code> 提供了 <code>tracer</code> 接口。 这个对象跟踪当前处于处理中的激活的 <code>Span</code>，并允许你通过他对当前的 <code>Span</code> 进行一些诸如添加 <code>Attributes</code> 、<code>Events</code> 信息的操作，并且当当前工作完成后结束本次的跟踪。通过 <code>Trace Provider</code> 在多个处理中可以创建一个或多个 <code>Trace</code> 对象，他提供了一个工厂接口提供了根据不同的配置创建多个 <code>Tracer</code> 的能力。</p>
<p>通常来说，一个 <code>Span</code> 的生命周期类似下面的描述：</p>
<ul>
<li>一个服务接收到了一个请求，如果存在对应的 <code>Header</code> 信息时，会有一个 <code>Span Context</code> 会通过请求的 <code>Header</code> 信息被创建出来</li>
<li>一个新的 <code>Span</code> 会作为子节点从提取的 <code>Context</code> 创建出来，如果 <code>Context</code> 不存在，则新的 根 <code>Span</code> 会被创建出来</li>
<li>服务开始处理当前的请求时，一些额外的 <code>Attribute</code> 跟 <code>Event</code> 会被添加到对应的 <code>Span</code> 中，用来提高当前 <code>Span</code> 对应请求的可理解性，比如机器的主机名或者是一些其他的标识符</li>
<li>可能会创建一些新的 <code>Span</code> 来表示一些其中某些子组件所完成的工作</li>
<li>当服务向其他的服务发出了远程服务调用时，当前 <code>Span Context</code> 会被序列化后发送给新的服务，并注入该 <code>Span Context</code> 到请求的 <code>Header</code> 或是消息中</li>
<li>当当前服务成功或失败的完成本轮处理时，<code>Span</code> 的状态会被合适的进行标识，并设置为已完成</li>
</ul>
<p>如果需要了解更多的信息，则可以通过 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#metric-signal">Traces Specification</a> 来得到更多关于: <code>Trace</code>、<code>Span</code>、父子关系、<code>Span Context</code>、<code>Attributes</code>、<code>Events</code>、跟 <code>Links</code> 的信息。</p>
<h2><a class="header" href="#metrics" id="metrics">Metrics</a></h2>
<p>指标 <code>Metrics</code> 是在服务运行时获取的度量工具。逻辑上，在某个时刻获取的这些被称为 <code>Metric</code> 事件的度量信息并不只包含度量信息，还包括了当时所能够捕获的其他相关的元数据。应用跟请求的指标是用来判断可用性跟性能的重要标准。自定义的指标则可以更清晰的指示出可用性会如何对用户的体验跟业务产生影响。那些被收集回来的数据可以用来作为中断的告警或是触发一些调度上的决定，比如在高负载的时候来自动扩容。</p>
<p><code>OpenTelemetry</code> 当前定义了三种指标仪表盘：</p>
<ul>
<li><strong>Counter</strong> 是一个跟随时间持续增长的值 - 你可以把他想象成汽车的里程数表，他只会持续的增长；</li>
<li><strong>Measure</strong> 是一个跟随时间进行聚合的值，他更像是汽车上的旅程表，可以用来某个时间区间的数据</li>
<li><strong>Observer</strong> 是在某个时间点捕获的一组值，更像是汽车上的燃油表</li>
</ul>
<p>除了这三个指标仪表盘，还有 <em>Aggregations</em> 聚合这个非常重要的概念需要深入理解。聚合是一种能将大量的度量值进行合并的技术，他最终能产生基于某个时间窗口的更具体或是模糊的结果。<code>OpenTelemetry</code> 的 <code>API</code> 并不提供进行这些聚合的能力，但他提供了一些基本的默认处理。通常来说，<code>OpenTelemetry SDK</code> 提供了一些常用的聚合 <em>(比如 Sum、Count、Last 跟  Histograms)</em>。用来为可视化跟其他的后端组件提供支撑。</p>
<p><code>Tracing</code> 是为了捕获请求的生命周期并为请求的各个独立的片段提供上下文，<code>Metric</code> 则倾向于提供基于聚合的一些统计信息，比如下面一些聚合的使用用例：</p>
<ul>
<li>报告某个服务所使用的每个传输协议所读取的数据量</li>
<li>报告整体的数据读取量以及每个请求的数据读取量</li>
<li>报告系统调用所消耗的时间</li>
<li>报告请求的数量用于确认整体的趋势</li>
<li>报告每个处理器的 CPU 或内存的使用量</li>
<li>报告账户的平均余额</li>
<li>报告当前正在处理的请求数</li>
</ul>
<p>如需要更多的信息，可以查看 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#metric-signal">Metrics Specification</a>，那里包含了关于 度量、仪表盘、指标、数据、数据点跟标签等信息。</p>
<h2><a class="header" href="#logs" id="logs">Logs</a></h2>
<p>日志是一个加上了时间戳的包含了元数据的文本记录，他可以是结构化 <em>(推荐)</em> 或是非结构化的。尽管日志是一个独立的数据源，他们依然可以跟 <code>Span</code> 进行关联。在 <code>OpenTelemetry</code> 中，任何不属于分布式跟踪或指标的数据都是日志。比如事件 <code>Events</code> 就是一种特定类型的日志。日志通常用来确认问题的根本原因，比如谁更改了什么或是产生了什么结果。</p>
<p>如需更多的信息， 可以查看 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#log-signal">Logs Specification</a>，那里包含了关于日志、定义字段、Trace Context 字段跟 Severity 字段。</p>
<h2><a class="header" href="#baggage" id="baggage">Baggage</a></h2>
<p>为了能够传递 Trace 信息， <code>OpenTelemetry</code> 提供了一个简易的称为 <code>Baggage</code> 的机制来传递键值对。<code>Baggage</code> 为同一个事务中的可观察事件提供了索引，用来访问那些由之前的服务产生 <code>Attributes</code>。这为事件之间因果关系的建立提供了支持。</p>
<p>虽然 <code>Baggage</code> 可以用来构建其他跨越多个碎片的原型，但这个机制主要还是用来表达那些用于体现 <code>OpenTelemetry</code> 系统的可观测性的值的。</p>
<p>这些值可以从 <code>Baggage</code> 中获取并作为额外的指标维度来进行消费，或者是作为日志跟 <code>Trace</code> 额外的上下文信息：</p>
<ul>
<li>这些额外的上下文信息可以给网络服务提供具体的请求来自哪个服务</li>
<li>一个 SaaS 提供方可以在上下文信息为接口提供请求中包含的用户或 Token 信息</li>
<li>确认某个图像服务中的故障跟特定浏览器版本的关系</li>
</ul>
<p>如需更多的信息，可以查看 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/overview.md#baggage-signal">Baggage Specification</a>。</p>
<h1><a class="header" href="#2-concepts---instrumenting" id="2-concepts---instrumenting">2. Concepts - Instrumenting</a></h1>
<p><code>OpenTelemetry</code> 项目可以用于快速构建应用的仪表信息的工具。仪表库为每个语言都提供了一个核心的库。他们不一定会提供额外的用于自动构建的仪表库或是其他的非核心组件。比如 Java 的仪表库提供了下面的几个库：</p>
<ul>
<li><a href="https://github.com/open-telemetry/opentelemetry-java">Core</a> 提供了一个实现了 OpenTelemtry API 跟 SDK 的用于手动构建的工具库</li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation">Instrumentation</a> 提供所有核心功能和各种库跟框架的自动检测的工具库</li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-contrib">Contrib</a> 可选的类似 JMX Metric Gather 的组件</li>
</ul>
<p>一些仪表库，如 <code>Ruby</code> 的则提供了单个仓库来同时提供手动跟自动的工具库。一些其他的语言，如 JS 则从 <code>Contrib</code> 库中分离出 <code>Core</code> 库，并以此将其分离成独立的两个分别实现手动跟自动能力的仪表库。</p>
<p><code>OpenTelemetry</code> 具体的安装机制要取决于具体的开发语言，但他们大部分都有下面几节所具有的共同点。</p>
<h2><a class="header" href="#automatic-instrumentation" id="automatic-instrumentation">Automatic Instrumentation</a></h2>
<h3><a class="header" href="#add-dependencies" id="add-dependencies">Add dependencies</a></h3>
<p>我们需要添加一个或多个依赖来启用自动仪表库，具体要添加的依赖则取决于具体的语言。但这些依赖都需要实现 <code>OpenTelemetry API</code> 跟 <code>SDK</code> 的功能。有一些语言需要为每个仪表库的单独添加依赖。可能还会需要添加对 <code>Expoter</code>  的依赖。要了解更多关于 <code>OpenTelemetry API</code> 跟 <code>SDK</code> 的信息，则需要参考 <a href="https://github.com/open-telemetry/opentelemetry-specification">Specification Repository</a>。</p>
<h3><a class="header" href="#configure-opentelemetry-instrumentation" id="configure-opentelemetry-instrumentation">Configure OpenTelemetry Instrumentation</a></h3>
<p>配置信息可以通过环境变量或是特定语言的机制来提供，比如在 Java 中则是使用系统属性 <em>(System Properties)</em>。但我们至少需要提供服务的名称来标识需要自动构建的服务。如下面所列的，还有一些其他的信息是可以配置的：</p>
<ul>
<li>指定数据源的配置信息</li>
<li><code>Exporter</code> 的配置信息</li>
<li><code>Propagator</code> 传播器的配置信息</li>
<li><code>Resource</code> 资源的配置</li>
</ul>
<h2><a class="header" href="#manual-instrumentation" id="manual-instrumentation">Manual Instrumentation</a></h2>
<h3><a class="header" href="#import-the-opentelemetry-api-and-sdk" id="import-the-opentelemetry-api-and-sdk">Import the OpenTelemetry API and SDK</a></h3>
<p>首先我们需要将 <code>OpenTelemetry</code> 引入我们的服务，如果你在开发通用库或其他一些会被一些可执行的程序使用的组件，那你应该只引入对 <code>API</code> 的依赖。如果你的目标是一个可以独立运行的程序或服务，那应该同时引入 <code>API</code> 跟 <code>SDK</code>。如果想了解更多关于 <code>OpenTelemetry</code> 的 <code>API</code> 跟 <code>SDK</code> 的相关信息，可以查看 <a href="https://github.com/open-telemetry/opentelemetry-specification">Specification Repository</a>。</p>
<h3><a class="header" href="#configure-the-opentelemetry-api" id="configure-the-opentelemetry-api">Configure the OpenTelemetry API</a></h3>
<p>为了能够创建 <code>Trace</code> 跟 <code>Metric</code> 信息，首先应该创建 <code>Tracer</code> 以及在需要的情况床架 <code>Meter Provider</code>。通常我们会建议 <code>SDK</code> 为这些对象的获取提供一个默认的单例 <code>Provider</code>，这样你就可以直接通过 <code>Provider</code> 得到所需的 <code>Tracer</code> 或是 <code>Meter</code> ，并为他们提供对应的名称或版本。你在这一步所选择的名称会作为后续仪表信息的标识符，所以如果你是在开发一个库，那你应该将这个名称的设置置于库的初始化之后 <em>(比如 com.legittimatebusiness.myLibrary 或其他的唯一标识)</em>，因为这个名称会将所有的 <code>Span</code> 跟 <code>Metric Event</code> 建立统一的命名空间。同时我们也推荐为其提供一个指定的版本 <em>(如semver:1.0.0)</em> 用来明确当前所使用的服务的对应版本。</p>
<h3><a class="header" href="#configure-the-opentelemetry-sdk" id="configure-the-opentelemetry-sdk">Configure the OpenTelemetry SDK</a></h3>
<p>如果你在构建的是一个服务程序，还会需要为 <code>SDK</code> 提供对应的配置信息，来指示应该如何导出 <code>OpenTelemetry</code> 的数据到后端。我们推荐将这些配置信息在程序中通过配置文件或其他的机制来提供。同样的每种编程语言可能都有相应的合适的配置。</p>
<h3><a class="header" href="#create-telemetry-data" id="create-telemetry-data">Create Telemetry Data</a></h3>
<p>在配置好 <code>API</code> 跟 <code>SDK</code> 后，就可以开始用从 <code>Provider</code> 中得到的 <code>Tracer</code> 跟 <code>Meter</code> 对象来创建 <code>Trace</code> 跟 <code>Metric Event</code> 信息了。你还可以使用一些便捷的插件或整合工具来创建 <code>Trace</code> 跟 <code>Metric Event</code> ，可以从这个 <a href="https://opentelemetry.io/registry">Registry</a> 或对应语言的仓库获取更多的信息。</p>
<h3><a class="header" href="#export-data" id="export-data">Export Data</a></h3>
<p>在你创建了 <code>Telemetry</code> 数据后，你需要将它发送到某个指定的地方，<code>OpenTelemetry</code> 主要支持两种方式来从你的程序中导出这些数据到对应的后端，你可以从程序直接发送也可以通过 <a href="https://opentelemetry.io/docs/collector">OpenTelemetry Collector</a> 进行代理。</p>
<p>在程序内部的导出需要你首先去导入所依赖的一个或多个 <code>Expoter</code>，以及相关的库，他们需要用来转换内存中的 <code>OpenTelemetry</code> 的 <code>Span</code> 及 <code>Metric</code> 数据为指定格式给诸如 <code>Jaeger</code> 或 <code>Prometheus</code> 的分析工具。并且，<code>OpenTelemetry</code> 通过 <code>SDK</code> 支持另一个广为人知的 <code>OTLP</code> 协议，这个协议可以用来发送数据给 <code>OpenTelemetry Collector</code> ，他是一个独立的可执行程序，可以用来作为代理或是服务的 <code>SideCar</code>，或是一个独立的主机。<code>Collector</code> 可以配置转发跟导出对应的数据到指定的分析工具。</p>
<p>除了 <code>Jaeger</code> 跟 <code>Prometheus</code> 这些开源工具外，还有越来越多其他的公司支持从 <code>OpenTelemetry</code> 中获取数据了，具体的信息可以参考 <a href="https://opentelemetry.io/vendors">这个</a> 页面。</p>
<h1><a class="header" href="#3-concept---instrumenting-libraries" id="3-concept---instrumenting-libraries">3. Concept - Instrumenting Libraries</a></h1>
<p><code>OpenTelemetry</code> 为许多的库提供了自动记录的仪表功能，他们通常都是通过一些库的 <code>Hook</code> 或者是 <code>Monkey-Patching</code> 等方式来完成的。</p>
<p><code>OpenTelemetry</code> 的原生仪表库提供了更好的可观察性跟开发体验，移除对库的依赖跟暴露出记录的 Hook:</p>
<ul>
<li>自定义的日志 Hook 可以使用通用且易于使用的 <code>OpenTelemetry API</code> 来替代，用户只需要跟 <code>OpenTelemetry</code> 进行交互</li>
<li><code>Trace</code>、<code>Log</code>、<code>Metric</code> 等程序中的信息会具有更好的关联性跟可靠</li>
<li>一致的约定能够让用户在使用不同的技术或编程语言时得到相近的体验</li>
<li><code>Telemetry Signal</code> 作为扩展点，可以用于在不同的场景中提供对数据进行微调 <em>(比如 Filtered、Processed、Aggregated)</em> 的支持</li>
</ul>
<h2><a class="header" href="#semantic-conventions" id="semantic-conventions">Semantic Conventions</a></h2>
<p>现在可用的 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/README.md">Semantic Conventions</a> 语义约定涵盖了 <code>Web-Frameworks</code>、<code>RPC 客户端</code>、<code>数据库</code>、<code>消息传递客户端</code>还有其他更多的定义。</p>
<p>如果你的库是其中的一种 - 就遵守对应的约定，他们描述了正确的来源并可以此来确定应该在对应的 <code>Span</code>  中附加哪些信息。预定可以让仪表信息更加统一：负责处理仪表数据的人可以在不需要学习库的特定细节，可视化的提供者也可以为各种技术提供支持 <em>(比如数据库或消息系统)</em> 。当各个库都遵守约定时，许多的使用场景就可以在无需用户在进行配置的情况下来使用了。</p>
<p>欢迎你来添加新的约定，<a href="https://cloud-native.slack.com/archives/C01QZFGMLQ7">Instrumentation Slack</a> 跟 <a href="https://github.com/open-telemetry/opentelemetry-specification">Specification Repo</a> 都可以是你的起点。</p>
<h2><a class="header" href="#when-not-to-instrument" id="when-not-to-instrument">When <strong>NOT</strong> to instrument</a></h2>
<p>有一些库可能只是对网络调用做了一层浅浅的封装，重点在于 <code>OpenTelemetry</code> 具有为底层的 <code>RPC</code>  调用自动记录仪表信息的功能，在这个情况下，库的仪表记录功能是不必要的：。</p>
<p>如果是下列的情况，<strong>不要</strong>记录仪表信息：</p>
<ul>
<li>你的库是一些位于顶层的自描述接口的一个轻量代理</li>
<li><em>OpenTelemtery</em> 为底层的网络调用记录了仪表信息</li>
<li>你的库没办法为对应的约定填充合适的信息</li>
</ul>
<p>如果不够确定，那就不要记录，你可以把他放到你确定需要的时候再来做这个事情。</p>
<p>尽管选择了不记录仪表信息，为你的内部 RPC 客户端实例提供一个配置 <code>OpenTelemetry</code> 处理器的能力也是好的。这对于那些没有完全支持自动记录仪表信息的语言来说，仍然是有用的。</p>
<p>剩余的文档则是介绍了当你想记录仪表信息时，应该如何做。</p>
<h2><a class="header" href="#opentelemetry-api" id="opentelemetry-api">OpenTelemetry API</a></h2>
<p>首先是要添加依赖 <em>OpenTelemtry API</em> 所需的包。</p>
<p><code>OpenTelemetry</code> 有两个主要的模块 - <code>API</code> 以及 <code>SDK</code>。<code>OpenTelemetry API</code> 是系列操作的抽象而不是实现。除非为应用再添加 <code>OpenTelemetry SDK</code> ，否则的话你的应用并不会记录任何东西，也不会对性能产生影响。</p>
<h3><a class="header" href="#libraries-should-only-use-opentelemetry-api" id="libraries-should-only-use-opentelemetry-api">Libraries should only use OpenTelemetry API</a></h3>
<p>你可能会理所当然的对添加新的依赖产生担忧，在这里我们会提供一些考量来帮助你如何最小化依赖所产生的 <code>Dependency Hell</code>：</p>
<ul>
<li><code>OpenTelemetry Trace API</code> 在 2021 年初期就实现了稳定，他也会遵循 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/versioning-and-stability.md">Semantic Versioning 2.0</a>  的语义来仔细的保持 API 的稳定性</li>
<li>在选择依赖时，使用最早的稳定版本的 <code>OpenTelemetry API (1.0.*)</code> 以及避免在不需要使用到新的 <code>Feature</code> 时进行升级</li>
<li>在你的仪表信息稳定时，考虑将它实现为一个独立的包：他不会对没使用到的地方产生任何影响。你可以将它保留在你的仓库也可以把他贡献给 <code>OpenTelemetry</code> 让他能够跟其他的仪表盘一起提供给他人使用</li>
<li>语义化的约定当前还没稳定，他不会导致任何功能上的问题，但你可能会需要每个一段时间更新一下。在预览插件或是将它保留在 <code>OpenTelemetry</code> 的其他仓库并不会造成什么破坏</li>
</ul>
<h3><a class="header" href="#getting-a-tracer" id="getting-a-tracer">Getting a tracer</a></h3>
<p>所有应用程序的配置都会被隐藏在库里的 <code>Tracer API</code> 里，这些库在默认的情况下，应该从全局的 <code>TracerProvider</code> 中获取。</p>
<pre><code class="language-java">private static final Tracer tracer = GlobalOpenTelemetry.getTracer(&quot;demo-db-client&quot;, &quot;0.1.0-beta&quot;);
</code></pre>
<p>为这些库提供一个接口允许应用传递一个明确的 <code>TracerProvider</code> 有助于更好的实现依赖注入及简化测试。</p>
<p>在使用你的库获取 <code>Tracer</code> 时提供指定的名称跟版本，他们会在遥测的数据上体现并能够帮助用户使用他们来对数据进行过滤、明确数据的具体来源，并以此来进行调试。</p>
<h2><a class="header" href="#what-to-instrument" id="what-to-instrument">What to instrument</a></h2>
<p>![image-20211020102106594](./3. Concept - Instrumenting Libraries.assets/image-20211020102106594.png)</p>
<h3><a class="header" href="#public-api" id="public-api">Public API</a></h3>
<p>开放的接口是非常合适监测的候选人：为开放接口创建的 <code>Span</code> 能够帮助用户将他们跟具体的应用代码建立关联，明确接口所调用的耗时跟结果。那哪些接口是应该监测的呢</p>
<ul>
<li>公开的、会在函数内部发起网络调用的、或是所需的本地需要花费大量时间或可能会失败的操作 <em>(比如 IO 操作)</em></li>
<li>用于处理请求或者是消息的</li>
</ul>
<h4><a class="header" href="#instrumentation-example" id="instrumentation-example">Instrumentation example:</a></h4>
<pre><code class="language-java">private static final Tracer tracer = GlobalOpenTelemetry.getTracer(&quot;demo-db-client&quot;, &quot;0.1.0-beta&quot;);

private Response selectWithTracing(Query query) {
	// check out conventions for guidance on span names and attributes
  Span span = tracer.spanBuilder(String.format(&quot;SELECT %s.%s&quot;, dbName, collectionName))
    .setSpanKind(SpanKind.CLIENT)
    .setAttribute(&quot;db.name&quot;, dbName)
    // ...
    .startSpan();
  
  // makes span active and allows correlating logs and nest spans
  try (Scope unused = span.makeCurrent()) {
    Response response = query.runWithRetries();
    if (response.isSuccessful()) {
      span.setStatus(StatusCode.OK);
    }
    if (span.isRecording()) {
    	// populate reponse attributes for reponse codes and other information
    }    
  } catch (Exception e) {
    span.recordException(e);
    span.setStatus(StatusCode.ERROR, e.getClass().getSimpleName());
    throw e;
  } finally {
    span.end();
  }
}
</code></pre>
<p>要严格遵守约定中需要填充的属性，如果没有可以填充的，则检查一下 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/span-general.md">通常的约定</a>。</p>
<h3><a class="header" href="#nested-network-and-other-spans" id="nested-network-and-other-spans">Nested network and other spans</a></h3>
<p>网络的调用通常会被 <code>OpenTelemetry</code> 的自动仪表库中对应的客户端实现进行跟踪。</p>
<p>如果 <code>OpenTelemetry</code> 还不支持跟踪你的网络客户端，就需要你自己来做出最好的决定了，下面的列表可能有助于你做出决定</p>
<ul>
<li>跟踪网络的调用是否会提高用户的可观察性或是提供其他能够帮助用户的能力？</li>
<li>你的库是不是对最顶层的公开的文档化的接口的包装？如果出现问题，用户需不需要获得底层服务的支持？
<ul>
<li>如果是则进行跟踪确保跟踪每个独立的网络尝试</li>
</ul>
</li>
<li>跟踪这些信息会不会是 <code>Span</code> 变得冗长？或是会否对性能产生影响？
<ul>
<li>使用日志或 <code>Span Event</code> 来处理冗长的信息。日志可以关联到父 <code>Span</code> <em>(即公开的接口)</em>  上，<code>Span Event</code> 也可以设置到公开接口的 <code>Span</code> 上</li>
<li>如果他们需要成为 <code>Span</code> <em>(比如为了作为独立的 Trace Context 进行传播)</em>，将他们放到配置的选项中并默认将其关闭</li>
</ul>
</li>
</ul>
<p>如果 <code>OpenTelemtry</code> 已经支持跟踪你的网络调用，，你应该不需要在做重复的事情了，但也有下面的一些例外：</p>
<ul>
<li>为没有使用自动仪表功能的用户提供支持 <em>(比如没有明确的运行环境或是对 Monkey-Paching 比较在的用户)</em></li>
<li>需要为底层的服务启用自定义的关联信息跟上下文传播协议</li>
<li>需要为某些自动仪表库没有完全覆盖到的库或服务填充 <code>Span</code> 信息</li>
</ul>
<p><u>WARNING:</u> 通用的用来避免重复的解决方案还在实现中</p>
<h3><a class="header" href="#events" id="events">Events</a></h3>
<p><code>Trace</code> 是你唯一需要提交的信息，<code>Event</code> 跟 <code>Log</code> 跟 <code>Trace</code> 是相互补充的，他们并不是相同重复的概念。通常来说，如果某些信息有可能会比较冗长，那他就更适合使用 <code>Log</code> 来体现，而不是 <code>Trace</code>。</p>
<p>如果你的库使用了日志库或是其他的一些类似的机制，检查 <a href="https://opentelemetry.io/registry/">OpenTelemetry Registry</a> 是否已经将其进行过整合了。整合通常指将当前活跃的 <code>Trace Context</code> 信息添加到所有的日志里，因此用户可以将这些信息进行关联。</p>
<p>如果你使用的编程语言跟环境没有通用的日志库，那就使用 <code>Span Event</code>  来体现那些需要提供给用户的额外的附加信息，在你想要添加 <code>Attribute</code> 的时候使用  <code>Event</code> 可能也会更加方便。</p>
<p>最后总结的规则是，使用 <code>Event</code> 或 <code>Log</code> 来替代 <code>Span</code> 记录那些可能会很冗长的信息。使用你当前持有的 <code>Span</code> 实例来添加 <code>Event</code>，在可能的情况下避免使用当前激活的 <code>Span</code>，因为你并不知道还有哪些其他的控制代码对其进行了引用。</p>
<h2><a class="header" href="#context-propagation" id="context-propagation">Context Propagation</a></h2>
<h3><a class="header" href="#extract-context" id="extract-context">Extract Context</a></h3>
<p>如果你处理的是基础的设施或是一个会接收上游请求的库，比如 <code>Web Framework</code> 或是 <code>Messaging Consumer</code>，你需要从到达的 请求或消息中提取所需的上下文。<code>OpenTelemetry</code> 提供了 <code>Propagator API</code> 用来隐藏特定的传播标准及从线路中读取 <code>Trace Context</code>。</p>
<p>在一个单独的响应中，只会在线路中读取出一个上下文信息，并会将它作为新 <code>Span</code> 的父节点。</p>
<p>在创建了新的 <code>Span</code> 后，你应该将其设置为激活的状态并尽可能明确的传递新的上下文给应用代码 <em>(通过回调或是处理函数)</em>。</p>
<pre><code class="language-java">// Extract the context
Context extractedContext = propagator.extract(Context.current(), httpExchange, getter);
Span span = tracer.spanBuider(&quot;receiver&quot;)
  .setSpanKind(SpanKind.SERVER)
  .setParent(extractedContext)
  .startSpan();

// make span active so any nested telemetry is correlated
try (Scope unused = span.makeCurrent()) {
  userCode();
} catch (Exception e) {
  span.recordException(e);
  span.setStatus(StatusCode.ERROR);
  throw e;
} finally {
  span.end();
}
</code></pre>
<p>这里还有一个完整的 <a href="https://opentelemetry.io/docs/java/manual_instrumentation/#context-propagation">Java 提取上下文</a> 的例子，其他编程语言的可以查看 <code>OpenTelemetry</code> 相关的文档。</p>
<p>在处理消息系统时，可能会一次收到超过一条的消息，这些消息可以通过 <a href="https://opentelemetry.io/docs/java/manual_instrumentation/#create-spans-with-links">Links</a> 整合到一个 <code>Span</code>，具体的可以参照 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/semantic_conventions/messaging.md">Message Conventions</a>。</p>
<p><u>WARN:</u> 这部分内容还处于建设中。</p>
<h3><a class="header" href="#injecting-context" id="injecting-context">Injecting Context</a></h3>
<p>当你要往外发送一个调用时，通常会需要将一些上下文信息传递给下游的服务。可以用 <code>Propagator API</code> 来创建一个新的 <code>Span</code> ，来将上下文注入到对外的调用消息里。可能还会有其他的一些场景需要用不同的方式来注入上下文，比如当你需要创建消息提供给异步的处理。</p>
<pre><code class="language-java">Span span = tracer.spanBuilder(&quot;send&quot;)
  .setSpanKind(SpanKind.CLIENT)
  .startSpan();

// make span active so any nested telemetry is corrlated
// even network calls might have nested layers of spans, log or events
try (Scope unused = span.makeCurrent()) {
  // inject the context
  propagator.inject(Context.current(), transportLayer, setter);
  send();
} catch (Exception e) {
  span.recordException(e);
  span.setStatus(StatusCode.ERROR);
  throw e;
} finally {
  span.end();
}
</code></pre>
<p>当然也可能会有例外：</p>
<ul>
<li>下游的服务不支持元数据或禁止接收未知的字段</li>
<li>下游的服务未定义关联的协议，服务未来的某个版本是否会开始支持上下文的传递，那就注入吧！</li>
<li>下游的服务支持自定义的关联协议
<ul>
<li>尽力去兼容自定义的传播器：在可以的情况下使用 <code>OpenTelemetry</code> 的 <code>Trace Context</code></li>
<li>或是在 <code>Span</code> 上生成跟添加自定义的关联 ID 信息</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#in-process" id="in-process">In-process</a></h3>
<ul>
<li><strong>激活你使用的 <code>Span</code></strong> <em>(即成为 current)</em> : 这样才能启用 <code>Span</code> 跟 <code>Log</code> 以及其他嵌套的自动仪表信息</li>
<li>如果库有 <code>Context</code> 的概念，支持 <strong>额外</strong> 的更具体的 <code>Trace Context</code> 加入当前的 <code>Span</code>
<ul>
<li>将 <code>Span</code> 添加到库的上下文中，并写明文档如何去使用他</li>
<li>允许用户在你的上下文中传递 <code>Trace Context</code></li>
</ul>
</li>
<li>在库中明确的传递 <code>Trace Context</code> - 因为当前的活跃 <code>Span</code> 在回调中可能会发生改变
<ul>
<li>尽快的从公开接口中捕获活跃的上下文，然后将它作为自身 <code>Span</code> 的父级上下文来使用</li>
<li>使用明确的实例来传递上下文并在其之上记录 <code>Attribute</code>、<code>Exeception</code>、``Event`等信息</li>
<li>这些都是必须的，如果你启动了一个线程在后台处理或是其他的一些异步的操作都可能会对上下文产生影响，但具体的限制还得看具体的编程语言</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#metrics-1" id="metrics-1">Metrics</a></h2>
<p><a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/api.md">Metric API</a> 当前还未稳定，并且我们还未完成对 <code>Metric</code> 约定的定义。</p>
<h2><a class="header" href="#misc" id="misc">Misc</a></h2>
<h3><a class="header" href="#instrumentation-registry" id="instrumentation-registry">Instrumentation Registry</a></h3>
<p>请将你的仪表库添加到 <a href="https://opentelemetry.io/registry/">OpenTelemetry Registry</a> 让更多其他的用户能够使用。</p>
<h3><a class="header" href="#performance" id="performance">Performance</a></h3>
<p><code>OpenTelemetry API</code> 在没有引入 <code>SDK</code> 的情况下并不会做任何操作。当 <code>OpenTelemetry SDK</code> 配置完成后，他也只会 <a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/performance.md">耗费有限的资源</a>。</p>
<p>在现实的应用中，特别是大规模的应用，通常会使用基于 Head-base 进行采样。抽样中的 <code>Span</code> 信息的成本应该是较低的，因此你应该检查 <code>Span</code> 是否处于 Recoding 状态，以此来避免在填充 <code>Attribute</code> 时产生额外的分配以及进行潜在的代价高昂的计算。</p>
<pre><code class="language-java">// some attribute are important for sampling, they should be provided at creation time
Span span = trace.spanBuilder(String.format(&quot;SELECT %s.%s&quot;, dbName, collectionName))
  .setSpanKind(SpanKind.CLIENT)
  .setAttribute(&quot;db.name&quot;, dbName)
  // ...
  .startSpan();

// other attributes, especially those that are expensive to calculate
// should be added if span is recoding
if (span.isRecording()) {
  span.setAttribute(&quot;db.statement&quot;, sanitize(query.statement()));
}
</code></pre>
<blockquote>
<p>简单来说就是确认当前的 <code>Span</code> 被采样及进行记录的前提下，才去计算复杂的 <code>Attribute</code></p>
</blockquote>
<h3><a class="header" href="#error-handling" id="error-handling">Error handling</a></h3>
<p><code>OpenTelemetry API</code> 在<a href="https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/error-handling.md#basic-error-handling-principles">运行时中是宽容的</a> - 他不会因为不合法的参数出错，不会抛出异常，会把出现的异常给隐藏起来。这样的话仪表库的问题就不会对应用的逻辑产生任何影响。</p>
<h3><a class="header" href="#testing" id="testing">Testing</a></h3>
<p>因为 <code>OpenTelemetry</code> 具有多种多样的自动化仪表采集，因此了解仪表库是如何跟其他的遥测数据交互是非常有用的：比如跟到达的请求、发出的请求、日志等。用一个使用了流行的框架跟库来实现的并启用了所有跟踪功能的应用，来测试你的仪表库，然后检查那些与你类似的库是如何使用的。</p>
<p>为了进行单元测试，你可以对 <code>SpanProcessor</code> 跟 <code>SpanExporter</code> 进行 Mock</p>
<pre><code class="language-java">@Test
public void checkInstrumentation() {
  SpanExporter exporter = new TestExporter();
  Tracer tracer = OpenTelemetrySdk.builder()
    .setTraceProvider(
    	SdkTracerProvider.builder()
    		.addSpanProcessor(SimpleSpanProcessor.create(exporter))
    		.build()
      ).build()
    .getTracer(&quot;test&quot;);
}

class TestExporter implements SpanExporter {
  public final List&lt;SpanData&gt; exportedSpans = Collections.synchronizedList(new ArrayList&lt;&gt;());
  
  @Override
  public CompletableResultCode export(Collection&lt;SpanData&gt; spans) {
    exportedSpans.addAll(spans);
    return CompletableResultCode.ofSuccess();
  }
}
</code></pre>
<h1><a class="header" href="#4-concept---data-collection" id="4-concept---data-collection">4. Concept - Data Collection</a></h1>
<p><code>OpenTelemetry</code> 项目通过 <code>OpenTelemetry Collector</code> 提供了便捷的收集遥测数据的能力。<code>OpenTelemetry Collector</code> 提供了一个与具体厂商无关的实现，描述应该如何接收、处理跟导出遥测数据。为了能够支持将开源的可观测数据格式 <em>(如 Jaeger 跟 Prometheus 等)</em> 发送到一个或多个开源的或商业的后端，他移除了运行、操作跟管理多个 Agent 或 Collector 的功能。另外，<code>Collector</code>允许终端用户能够控制他们的数据。默认的情况下 <code>Collector</code> 是接收仪表库的遥测数据的默认选择。</p>
<blockquote>
<p><code>Collector</code> 还能提供分布式的支持，具体的可以查看 <a href="https://opentelemetry.io/docs/concepts/distributions">这里</a> 来获取更多的信息</p>
</blockquote>
<h2><a class="header" href="#deployment" id="deployment">Deployment</a></h2>
<p><code>OpenTelemetry Collector</code> 提供了一个独立的二进制程序以及两种部署的方式：</p>
<ul>
<li><strong>Agent</strong>: <code>Collector</code> 的实例跟应用一起运行，或者是在同一个机器上作为一个程序来运行 <em>(比如二进制文件、SideCar 或 Daemonset)</em></li>
<li><strong>Gateway</strong>: 一个或多个 <code>Collector</code> 实例作为独立的服务 <em>(比如作为一个 Container 或 Deployment)</em> ，比如每个集群、数据中心、区域都有一个</li>
</ul>
<p>更多的如何使用 <code>Collector</code> 的信息可以参考 <a href="https://opentelemetry.io/docs/collector/getting-started">Getting Started Documention</a>。</p>
<h2><a class="header" href="#components" id="components">Components</a></h2>
<p><code>Collector</code> 由下面的几个组件组成</p>
<ul>
<li><strong>Receiver</strong> 定义了如何将消息接收到 <code>Collector</code>，他们可以是基于 Push 或是 Pull 模式的</li>
<li><strong>Processor</strong> 定义了需要对接收的数据进行何种处理</li>
<li><strong>Exporter</strong> 定义了要将接收到的数据发送到什么地方，他们也可以是基于 Push 或是 Pull 模式的</li>
</ul>
<p>这些组件是通过 <code>PipeLines</code> 启用的，这些组件可以通过 YAML 同时定义多个实例。</p>
<p>关于这些组件的更多信息可以参考 <a href="https://opentelemetry.io/docs/collector/configuration">Configuration Documentation</a>。</p>
<h2><a class="header" href="#repositories" id="repositories">Repositories</a></h2>
<p><code>OpenTelemetry</code> 项目提供了两种版本的 <code>Collector</code>:</p>
<ul>
<li><strong><a href="https://github.com/open-telemetry/opentelemetry-collector/releases">Core</a></strong> 基础组件，如配置跟通用的可适配的 <code>Receiver</code>、<em>Processor</em>、<code>Exporter</code> 跟其他的扩展。为流行的开源项目如 Jaeger、Prometheus 跟 Fluent 等项目提供了支持。</li>
<li><strong><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/releases">Contrib</a></strong> 所有的组件都在 Core 版本上面做了增强或者是提供了其他实验性的组件。包括了更为特化了的适配特定厂商的 <code>Receiver</code>、<code>Processor</code>、<code>Exporter</code> 跟扩展。</li>
</ul>
<h1><a class="header" href="#5-concept---distributions" id="5-concept---distributions">5. Concept - Distributions</a></h1>
<p><code>OpenTelemetry</code> 项目由多种不同的支持多种 <a href="https://opentelemetry.io/docs/concepts/data-sources">数据源</a> 的  <a href="https://opentelemetry.io/docs/concepts/components">组件</a> 组成。对应的实现手册可以参照</p>
<ul>
<li><a href="https://opentelemetry.io/docs/concepts/instrumenting">Language-Specific Instrumentation Libraries</a></li>
<li><a href="https://opentelemetry.io/docs/concepts/data-collection">A Collector Binary</a></li>
</ul>
<p>可以从任何实现的参考来创建新的发行版本。</p>
<h2><a class="header" href="#what-is-a-distribution" id="what-is-a-distribution">What is a distribution</a></h2>
<p>不要将发行版跟 Fork 混淆，发行版是一个 <code>OpenTelemetry</code> 组件的自定义版本。一个发行版是基于现有的 <code>OpenTelemetry</code> 仓库来进行自定义的，自定义的发行版可能会包括：</p>
<ul>
<li>一些为提高指定的后端或者厂商易用性的脚本</li>
<li>为指定的后端、厂商或终端用户重新适配的默认设置</li>
<li>为指定的厂商或用户添加的为配置项</li>
<li>提供比 <code>OpenTelemetry</code> 所支持的更好的测试、性能跟安全性</li>
<li>一些比 <code>OpenTelemetry</code> 所没有提供的额外功能</li>
<li>或是将 <code>OpenTelemetry</code> 的功能进行了精简</li>
</ul>
<p>发行版大致上可以归入以下几类</p>
<ul>
<li>&quot;<strong>Pure</strong>&quot;: 这种发行版提供跟上游版本 100% 兼容的功能，个性化的地方一般会在于提高易用性或将功能进行封装。这些个性化的可能会是为某些指定的后端、厂商或用户而做的</li>
<li>“<strong>Plus</strong>”: 这种发行版提供了跟上游版本相同的功能的同时会对其进行加强。这些比 <strong>Pure</strong> 更强的个性化功能可能会包含在额外的组件中。比如会提供上游项目中未提供的支持某些特定厂商的自动仪表库或 <code>Exporter</code> 等</li>
<li>“<strong>Minus</strong>”: 这种发行版将上游提供的功能进行了精简。比如会将自动仪表库移除，或是将 <code>Collector</code> 中的 <code>Receiver</code>/<code>Processor</code>/<code>Exporter</code>/<code>Extension</code> 等移除。这些发行版可能还会针对支持的广泛性跟安全性考虑进行了特定的加强。</li>
</ul>
<h2><a class="header" href="#who-would-create-a-distribution" id="who-would-create-a-distribution">Who would create a distribution</a></h2>
<p>任何人都可以创建新的发行版，现在已经有许多的<a href="https://opentelemetry.io/vendors">厂商</a>提供了自己的发行版。还有些终端用户如果需要用到不在 <code>OpenTelemetry</code> 项目中的组件，他们也会考虑创建自己的发行版。</p>
<h2><a class="header" href="#creating-you-own-distribution" id="creating-you-own-distribution">Creating you own distribution</a></h2>
<h3><a class="header" href="#collector" id="collector">Collector</a></h3>
<p>这篇文章 <a href="https://medium.com/p/42337e994b63">Building your own OpenTelemetry Collector Distribution</a> 可以指导你如何去创建自己的发行版。</p>
<p>如果你想要创建自己的发行版本，那 <a href="https://github.com/open-telemetry/opentelemetry-collector-builder">OpenTelemetry Collector Builder</a> 会是一个很好的起点。</p>
<h2><a class="header" href="#what-you-should-know-about-distributions" id="what-you-should-know-about-distributions">What you should know about distributions</a></h2>
<p><code>OpenTelemetry</code> 项目当前并未对发行版进行验证。可能在未来 <code>OpenTelemetry</code> 会像 Kubernetes 那样对发行版或者合作伙伴进行认真，来确保发行版不会被特定的厂商所限制。</p>
<h1><a class="header" href="#6-collector---getting-started" id="6-collector---getting-started">6. Collector - Getting Started</a></h1>
<p>请先回顾下 <a href="https://opentelemetry.io/docs/concepts/data-collection">Data Collection Documentation</a> 确保能理解 <code>OpenTelemetry</code>中 <code>Collector</code> 的部署模型、组件跟适用的仓库。</p>
<h2><a class="header" href="#deployment-1" id="deployment-1">Deployment</a></h2>
<p><code>OpenTelemetry Collector</code> 包含一个独立的二进制文件以及提供了两种主要的部署方式</p>
<ul>
<li><strong>Agent</strong>: <code>Collector</code> 的实例会更应用一起运行或是在同一个主机上运行 *(比如二进制文件、SideCar、Daemon set)</li>
<li><strong>Gateway</strong>: 通常来说为每个集群、数据中心或区域中，将一个或多个 <code>Collector</code> 的实例作为独立运行的服务 <em>(比如是一个 Container 或是一个 Deployment)</em> 进行部署。</li>
</ul>
<h3><a class="header" href="#agent" id="agent">Agent</a></h3>
<p>我们会推荐在每个主机中以 Agent 的形式部署到对应的环境中。这样的话，Agent 就可以拦截所有接收的遥测数据 <em>(包括 Pull 跟 Push 两种)</em>，同样也可以为这些遥测数据添加更具体的元数据，比如自定义的标签或是基础设施的信息。另外，Agent 也可以无需去负责类似客户端所需要做的类似批量处理、重试、加密、压缩等操作。<code>OpenTelemetry</code> 仪表库默认情况下会假设本地的 <code>Collector</code> 是就绪的并将数据导出。</p>
<h3><a class="header" href="#gateway" id="gateway">Gateway</a></h3>
<p>另外一种是作为网关集群部署到每个集群、数据中心或地区，网关集群会作为独立的服务因此他相对于 Agent 这种基于采样的模式，能够提供更加强大的能力。另外，网关集群还可以限制发送数据的出站点的数量及进行 API Token 的统一管理。每个集群中的 <code>Collector</code> 实例都能够独立处理数据，因此能够很容易的使用负载均衡器针对性能所需来进行扩展。在网关集群部署之后，他通常就会开始接收从 Agent 发过来的信息了。</p>
<h2><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h2>
<h3><a class="header" href="#demo" id="demo">Demo</a></h3>
<p>Demo 会部署负载生成器、Agent 跟网关以及 Jaeger、ZipKin 跟 Prometheus 作为后端。更多的信息可以从 Demo 的 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/examples/demo">README.md</a> 了解。</p>
<pre><code class="language-bash">$ git clonet git@github.com:open-telemetry/opentelemetry-collector-contrib.git; \
	cd opentelemetry-collector-contrib/examples/demo; \
	docker-compose up -d
</code></pre>
<h3><a class="header" href="#docker" id="docker">Docker</a></h3>
<p>每个 <code>Collector</code> 版本都会发布到 Docker Hub 并附带默认的配置文件</p>
<pre><code class="language-bash">$ docker run otel/opentelemetry-collector
</code></pre>
<p>还可以使用他提供的示例，这个示例会使用 Docker Container 启动一个 <code>Collector</code> 的 Core 版本，启用所有的 <code>Receiver</code>，并将所有的数据导出到本地的文件中。发送到容器的数据会从中提取出所需的 Prometheus 指标。</p>
<pre><code class="language-bash">$ git clone git@github.com:open-telemetry/opentelemetry-collector.git; \
	cd opentelemetry-collector/examples; \
	go build main.go; ./main &amp; pid1=&quot;$!&quot;;
	docker run -- rm -p 13133:13133 -p 14250:14250 -p 14268:14268 \
	-p 55678-55679:55678-55679 -p 4317:4317 -p 8888:8888 -p 9411:9411 \
	-v &quot;${PWD}/otel-local-config.yaml&quot;:/otel-local-config.yaml \
	--name otecol otel/opentelemetry-collector \
	--config otel-local-config.yaml; \
	kill $pid1; docker stop otelcol
</code></pre>
<h3><a class="header" href="#kubernetes" id="kubernetes">Kubernetes</a></h3>
<p>部署了一个类型为 Deamonset 的 Agent ，以及一个独立的网关实例</p>
<pre><code class="language-bash">$ kubectl apply -f https://raw.githubusercontent.com/open-telemetry/opentelemetry-collector/main/examples/k8s/otel-config.yaml
</code></pre>
<p>上例只是作为一个起点的示范，在上实际的生产环境之前需要在进行自定义的配置。</p>
<p><code>OpenTelemetry Operator</code> 可以用来提供管理 <code>OpenTelemetry Collector</code> 实例的工具，通过他的类似自动升级处理的功能，能够实现基于 <code>OpenTelemetry</code> 配置的服务配置，跟自动进行 SideCar 的配置注入等等。</p>
<h3><a class="header" href="#nomad" id="nomad">Nomad</a></h3>
<p>Reference job files to deploy the Collector as an agent, gateway and in the full demo can be found athttps://github.com/hashicorp/nomad-open-telemetry-getting-started.</p>
<h3><a class="header" href="#linux-packaging" id="linux-packaging">Linux Packaging</a></h3>
<p>Every Collector release includes DEB and RPM packaging for Linux amd64/arm64 systems. The packaging includes a default configuration that can be found at <code>/etc/otel-collector/config.yaml</code> post-installation.</p>
<blockquote>
<p>Please note that systemd is require for automatic service configuration</p>
</blockquote>
<p>To get started on Debian systems run the following replacing <code>v0.20.0</code> with the version of the Collector you wish to run and <code>amd64</code> with the appropriate architecture.</p>
<pre><code class="language-bash">$ sudo apt-get update
$ sudo apt-get -y install wget systemctl
$ wget https://github.com/open-telemetry/opentelemetry-collector/releases/download/v0.20.0/otel-collector_0.20.0_amd64.deb
$ dpkg -i otel-collector_0.20.0_amd64.deb
</code></pre>
<p>To get started on Red Hat systems run the following replacing <code>v0.20.0</code> with the version of the Collector you wish to run and <code>x86_64</code> with the appropriate architecture.</p>
<pre><code class="language-bash">$ sudo yum update
$ sudo yum -y install wget systemctl
$ wget https://github.com/open-telemetry/opentelemetry-collector/releases/download/v0.20.0/otel-collector_0.20.0-1_x86_64.rpm
$ rpm -ivh otel-collector_0.20.0-1_x86_64.rpm
</code></pre>
<p>By default, the <code>otel-collector</code> systemd service will be started with the <code>--config=/etc/otel-collector/config.yaml</code> option after installation. To customize these options, modify the <code>OTELCOL_OPTIONS</code> variable in the <code>/etc/otel-collector/otel-collector.conf</code> systemd environment file with the appropriate command-line options (run <code>/usr/bin/otelcol --help</code> to see all available options). Additional environment variables can also be passed to the <code>otel-collector</code> service by adding them to this file.</p>
<p>If either the Collector configuration file or <code>/etc/otel-collector/otel-collector.conf</code> are modified, restart the<code>otel-collector</code> service to apply the changes by running:</p>
<pre><code class="language-bash">$ sudo systemctl restart otel-collector
</code></pre>
<p>To check the output from the <code>otel-collector</code> service, run:</p>
<pre><code class="language-bash">$ sudo journalctl -u otel-collector
</code></pre>
<h3><a class="header" href="#windows-packaging" id="windows-packaging">Windows Packaging</a></h3>
<p>Every Collector release includes EXE and MSI packaging for Windows amd64 systems. The MSI packaging includes a default configuration that can be found at <code>\Program Files\OpenTelemetry Collector\config.yaml</code>.</p>
<blockquote>
<p>Please note the Collector service is not automatically started</p>
</blockquote>
<p>The easiest way to get started is to double-click the MSI package and follow the wizard. Silent installation is also available.</p>
<h3><a class="header" href="#local" id="local">Local</a></h3>
<p>Builds the latest version of the collector based on the local operating system, runs the binary with all receivers enabled and exports all the data it receives locally to a file. Data is sent to the container and the container scrapes its own Prometheus metrics.</p>
<pre><code class="language-bash">$ git clone git@github.com:open-telemetry/opentelemetry-collector-contrib.git; \
    cd opentelemetry-collector-contrib/examples/demo; \
    go build client/main.go; ./client/main &amp; pid1=&quot;$!&quot;; \
    go build server/main.go; ./server/main &amp; pid2=&quot;$!&quot;; \

$ git clone git@github.com:open-telemetry/opentelemetry-collector.git; \
    cd opentelemetry-collector; make install-tools; make otelcol; \
    ./bin/otelcol_$(go env GOOS)_$(go env GOARCH) --config ./examples/local/otel-config.yaml; kill $pid1; kill $pid2
</code></pre>
<h1><a class="header" href="#7-metrics---api" id="7-metrics---api">7. Metrics - API</a></h1>
<p>[TOC]</p>
<p>Metrics API 包含下面几个主要的组件</p>
<ul>
<li><code>MeterProvider</code> 作为提供 <code>Meter</code>  的入口</li>
<li><code>Meter</code> 则负责创建 <code>Instruments</code> </li>
<li><code>Instruments</code> 则负责报告本章所涉及的各种 <code>Measurements</code> 指标</li>
</ul>
<p>简单来介绍，他们之间的层级结构是这样的 </p>
<pre><code class="language-python">+-- MeterProvider(default)
    |
    +-- Meter(name='io.opentelemetry.runtime', version='1.0.0')
    |   |
    |   +-- Instrument&lt;Asynchronous Gauge, int&gt;(name='cpython.gc', attributes=['generation'], unit='kB')
    |   |
    |   +-- instruments...
    |
    +-- Meter(name='io.opentelemetry.contrib.mongodb.client', version='2.3.0')
        |
        +-- Instrument&lt;Counter, int&gt;(name='client.exception', attributes=['type'], unit='1')
        |
        +-- Instrument&lt;Histogram, double&gt;(name='client.duration', attributes=['net.peer.host', 'net.peer.port'], unit='ms')
        |
        +-- instruments...

+-- MeterProvider(custom)
    |
    +-- Meter(name='bank.payment', version='23.3.5')
        |
        +-- instruments...
</code></pre>
<blockquote>
<p>MeterProvider 用来创建 Meter, 每个 Meter 都会使用唯一的名称来创建，并负责一个独立的模块，在这个 Meter 下面会根据具体的指标来创建对应类型的 Instrument，比如上图中的 <code>io.opentelemetry.contrib.mongodb.client</code> 负责跟踪 MongoDb 的客户端信息，客户端信息中又包含了客户端的异常统计指标 <em>(<code>Counter</code>)</em>， 客户端的查询耗时指标 <em>(<code>Histogram</code>)</em></p>
</blockquote>
<h2><a class="header" href="#meterprovider" id="meterprovider">MeterProvider</a></h2>
<p><code>Meter</code> 可以通过 <code>MeterProvider</code> 来创建跟访问，在使用它创建 <code>Meter</code> 的时候应该提供一个唯一有意义的名称，比如 <code>io.opentelemetry.contrib.mongodb</code> 来描述具体需要监控的对象、模块。</p>
<h2><a class="header" href="#meter" id="meter">Meter</a></h2>
<p><code>Meter</code> 的责任是创建 <code>Instruments</code>，即各种所需的指标，需要注意的是 <code>Meter</code> 不应该去负责各种配置问题，配置的责任应该是在 <code>MeterProvider</code> 中。</p>
<h3><a class="header" href="#meter-operations" id="meter-operations">Meter Operations</a></h3>
<p><code>Meter</code> 可以使用下列接口来创建 <code>Instruments</code>:</p>
<ul>
<li><a href="7_Metrics_API.html#Counter">Create a new Counter</a></li>
<li>[Create a new Asynchronous Counter](#Asynchronous Counter)</li>
<li><a href="7_Metrics_API.html#Histogram">Create a new Histogram</a></li>
<li><a href="7_Metrics_API.html#Gauge">Create a new Asynchronous Gauge</a></li>
<li><a href="7_Metrics_API.html#UpDownCounter">Create a new UpDownCounter</a></li>
<li>[Create a new Asynchronous UpDownCounter](#Asynchronous UpDownCounter)</li>
</ul>
<h2><a class="header" href="#instrument" id="instrument">Instrument</a></h2>
<p><code>Instruments</code> 会用来报考指标信息，每个 <code>Instrument</code> 都会具有下列的信息</p>
<ul>
<li>Name 名称
<ul>
<li>非空的、大小写敏感的、最大长度为 63 个字符的ASCII 码符号</li>
</ul>
</li>
<li>Kind 类型
<ul>
<li>可以是下面将列举的各种 <code>Instrument</code>，并且会分成同步跟异步两种，具体可以看下面的解释</li>
</ul>
</li>
<li>可选的 Unit 单元
<ul>
<li>当 Unit 为空或未提供时，API 的 SDK 需要将其作为空字符串来对待</li>
<li>大小写敏感，即 <code>Kb</code> 跟 <code>kB</code> 会被视为是不同的单元</li>
</ul>
</li>
<li>可选的 Description 描述</li>
</ul>
<h3><a class="header" href="#synchrounous-and-asynchrounous" id="synchrounous-and-asynchrounous">Synchrounous and Asynchrounous</a></h3>
<p><code>Synchronous</code> 同步的意味着需要应用或者业务自己去处理相关的逻辑，比如 HTTP 客户端会使用 <code>Counter</code> 来记录接收到的字节数，并且同步的 <code>Instrument</code> 可以跟当时执行的上下文建立关联</p>
<p><code>Asynchrounous</code> 异步的意味着处理的逻辑是一个由用户注册到 <code>Instrument</code> 的回调函数，并且他只会在触发收集指标的时候被调用，比如一个嵌入式的软件会使用异步的 <code>Gauge</code> 每隔 15 秒收集一次传感器的温度，这意味着这个函数会每隔 15 秒被调用一次，最后异步的指标信息无法跟当时执行的上下文进行关联。</p>
<h3><a class="header" href="#counter" id="counter">Counter</a></h3>
<p><code>Counter</code> 是一个只支持非负增长信息的同步的 <code>Instrument</code>。比如我们会用 <code>Counter</code> 来记录：</p>
<ul>
<li>统计接收的字节数</li>
<li>统计已完成的请求数</li>
<li>统计已创建的账户</li>
<li>统计检查点执行的次数</li>
<li>统计 HTTP 500 错误的个数</li>
</ul>
<h4><a class="header" href="#counter-creation" id="counter-creation">Counter Creation</a></h4>
<p><code>Counter</code> 只能通过 <code>Meter</code> 来进行创建，用于创建 <code>Counter</code> 的接口需要接收三个参数</p>
<ul>
<li>Name 名称，同样遵循 Instrument 的命名规范</li>
<li>可选的 Unit，同样遵循 Instrument 的单元规范</li>
<li>可选的 Description，同样遵循 Instrument 的描述规范</li>
</ul>
<p>下面是创建接口的示例</p>
<pre><code class="language-python">exception_counter = meter.create_counter(name=&quot;exceptions&quot;, description=&quot;number of exceptions caught&quot;, value_type=int)
</code></pre>
<h4><a class="header" href="#counter-operations" id="counter-operations">Counter Operations</a></h4>
<h5><a class="header" href="#add" id="add">Add</a></h5>
<p>为 Counter 递增一个指定的非负值，该接口还可以接收一个额外的 <code>Attributes</code> 属性参数，这个属性参数应该可以在调用 Add 的时候动态的赋值，而不是在创建 <code>Instrument</code> 的时候进行注册，下面是接口的示例</p>
<pre><code class="language-python">exception_counter.Add(1, {&quot;exception_type&quot;: &quot;IOError&quot;, 'handled_by_user&quot;: Trye'})
exception_counter.Add(1, exception_type=&quot;IOError&quot;, handled_by_user=True)
</code></pre>
<h3><a class="header" href="#asynchronous-counter" id="asynchronous-counter">Asynchronous Counter</a></h3>
<p>异步的 <code>Counter</code> 是一个异步的 <code>Instrument</code>，在对应的 <code>Instrument</code> 被检测时会报告一系列单调递增的值。比如我们会使用异步的 <code>Counter</code> 来跟踪下面的指标</p>
<ul>
<li>可以用来报告每个线程、每个处理器或是整个系统的 CPU Time，比如处理器 A 在用户态所花费的以秒为单元的时间</li>
<li>每个处理器所产生的 Page Faults</li>
</ul>
<h4><a class="header" href="#asynchronous-counter-creation" id="asynchronous-counter-creation">Asynchronous Counter Creation</a></h4>
<p>异步的 <code>Counter</code> 只能由 <code>Meter</code> 来创建，并推荐实现的名称类似为 <code>ObservableCounter</code>。用于创建异步 <code>Counter</code> 的接口应该接收下面四个参数：</p>
<ul>
<li>Name 参数，遵循 <code>Instrument</code> 的命名规范</li>
<li>可选的 Unit 参数，遵循 <code>Instrument</code> 的单元规范</li>
<li>可选的 Description 参数，遵循 <code>Instrument</code> 的描述规范</li>
<li>Callback 回调函数</li>
</ul>
<p><code>Callback</code> 回调函数负责报告所需的指标信息，他只会在 <code>Meter</code> 被进行检测的时候调用，具体的 API 需要定义该接口是否是可重入的或是线程安全的。</p>
<p>该回调函数不应该耗费大量的时间，如果多个独立的 SDK 上下文同时共存，他们需要独立的触发这些回调。</p>
<p><code>OpenTelemetry API</code> 的实现者可以从下面两种方式中进行挑选，确定实现方案</p>
<ul>
<li>返回一个列表 <em>(或是元祖、生成器之类的)</em> 来代表一系列指标</li>
<li>可以使用一个观察者对象作为回调的参数来允许用户独立的设置需要报告的指标信息</li>
</ul>
<p>我们还建议用户的代码不要在一个回调中，为不同的指标设置相同的属性，如果设置了，<code>OpenTelemetry SDK</code> 的实现者会在 SDK 中自己选择如何处理这些指标。比如在一个回调中返回了两个指标，<code>value = 1, attributes={pid:4, bitness:64}</code> 以及 <code>value=2, attributes={pid:4, bitness:64}</code>，那 SDK 的开发者可能会选择忽略这些指标、选择第一个、选择最后一个、或是其他的处理方式都可能。一个单独的回调结果，会被作为一个独立的观测结果进行处理，比如他们会有一个唯一的时间戳。</p>
<p>下面是该接口的示例</p>
<pre><code class="language-python">def pf_callback():
  return (
    (8,        (&quot;pid&quot;, 0), (&quot;bitness&quot;, 64),
    (37741921, (&quot;pid&quot;, 4), (&quot;bitness&quot;, 64),
    (10465,    (&quot;pid&quot;, 880), (&quot;bitness&quot;, 32),
  )
     
meter.create_observable_counter(
  name=&quot;PF&quot;, description=&quot;process page faults&quot;, pf_callback
)
</code></pre>
<pre><code class="language-python">def pf_callback(result):
    # Note: in the real world these would be retrieved from the operating system
    result.Observe(8,        (&quot;pid&quot;, 0),   (&quot;bitness&quot;, 64))
    result.Observe(37741921, (&quot;pid&quot;, 4),   (&quot;bitness&quot;, 64))
    result.Observe(10465,    (&quot;pid&quot;, 880), (&quot;bitness&quot;, 32))

meter.create_observable_counter(
  name=&quot;PF&quot;, description=&quot;process page faults&quot;, pf_callback
)
</code></pre>
<h4><a class="header" href="#asynchronous-counter-operations" id="asynchronous-counter-operations">Asynchronous Counter Operations</a></h4>
<p>异步的 <code>Counter</code>只准备用于异步的场景，所以唯一的操作是由初始化时所提供的 <code>callback</code> 回调来完成的。</p>
<h3><a class="header" href="#histogram" id="histogram">Histogram</a></h3>
<p><code>Histogram </code> 是一个同步的 <code>Instrument</code>，可以被用来报告特定的数值，这些数值后续可能会被用来做一些有意义的统计分析，他们通常会被用来作为生成直方图  <em>(Histograms)</em> 、汇总 <em>(Summaries)</em> 或一些百分位 <em>(percentile)</em> 信息。比如下面是用 <code>Histogram</code> 的几个例子</p>
<ul>
<li>请求的耗时</li>
<li>响应消息的大小</li>
</ul>
<h4><a class="header" href="#histogram-creation" id="histogram-creation">Histogram Creation</a></h4>
<p>除了 <code>Meter</code> 之外不应该有其他的方式来创建 <code>Histogram</code>。在 <code>Meter</code> 可以用类似 <code>CreateHistogram</code>的函数来创建。这个创建的函数必须接收下列这些参数</p>
<ul>
<li><code>Name</code> 参数，遵循 <code>Instrument</code> 命名规范</li>
<li>可选的 <code>Unit</code> 参数，遵循 <code>Instrument</code>单元命名规范</li>
<li>可选的 <code>Description</code> 参数，遵循 <code>Instrument</code> 描述规范</li>
</ul>
<p>下面是 <code>OpenTelemetry API</code> 作者在实现时可以考虑以下列示例的形式</p>
<pre><code class="language-python">http_server_duration = meter.create_histogram(
  name=&quot;http.server.duration&quot;,
  description=&quot;measures the duration of the inbound HTTP request&quot;,
  unit=&quot;millseconds&quot;,
  value_type=float
)
</code></pre>
<h4><a class="header" href="#histogram-operations" id="histogram-operations">Histogram Operations</a></h4>
<h5><a class="header" href="#record" id="record">Record</a></h5>
<p>使用指定的值来更新分析信息。这个接口不应该返回任何的值，它的参数是</p>
<ul>
<li>当前 <code>Measurement</code> 指标的值，该值必须是一个非负的值</li>
<li>可选的 <code>Attrubutes</code> 属性</li>
</ul>
<p><code>OpenTelemetry API</code> 的作者来选择如何灵活的传递属性，下面是接口的示例</p>
<pre><code class="language-python">http_server_duration.Record(50, {&quot;http.method&quot;: &quot;POST&quot;, &quot;http.scheme&quot;: &quot;http&quot;})
http_server_duration.Record(100, http_method=&quot;GET&quot;, http_scheme=&quot;http&quot;)
</code></pre>
<h3><a class="header" href="#asynchronous-gauge" id="asynchronous-gauge">Asynchronous Gauge</a></h3>
<p><code>Gauge</code> 是一个异步的用来报告 <code>non-additive</code> 非附加性的值的 <code>Instrument</code>，<em>(比如房间的温度，这个温度对于其他的房间来说是没有意义的， 所以他不会被用来进行累加之类的操作)</em>。</p>
<blockquote>
<p>注意，如果这个值是 <code>additive</code> 有附加性的，<em>(比如处理器的堆大小 - 他在用来报告多个处理器中每个处理器的大小并会被累加起来作为总体的堆大小的话)</em> 那就应该使用 [Asyncronous Counter](#Asynchronous Counter) 或是 [Asynchronous UpDownCounter](#Asynchronous UpDownCounter)。</p>
</blockquote>
<p>下面是使用 <code>Gauge</code> 的例子</p>
<ul>
<li>当前房间的温度</li>
<li>CPU 的风扇速度</li>
</ul>
<h4><a class="header" href="#asynchronous-gauge-creation" id="asynchronous-gauge-creation">Asynchronous Gauge Creation</a></h4>
<p>异步的 <code>Gauge</code> 只能够使用 <code>Meter</code> 来创建，他可能是同时使用类似名为 <code>CreateObservableGauge</code> 的函数。创建这个对象的函数需要接收下面的参数</p>
<ul>
<li><code>Name</code> 参数，遵循 <code>Instrument</code> 命名规范</li>
<li>可选的 <code>Unit</code> 指标，遵循 <code>Instrument</code> 单元规范</li>
<li>可选的 <code>Description</code> ，遵循 <code>Instrument</code> 描述规范</li>
<li><code>Callback</code> 回调函数</li>
</ul>
<p>回调函数只会在对应的 <code>Meter</code> 被进行观察的时候调用，并需要负责报告所需的指标信息，同时这个回调函数不应该花费不确定的大量的时间，如果运行中的运用中有多个独立的 SDK ，他们之间对这个回调函数的调用也应该是独立的。</p>
<p><code>OpenTelemetry API</code> 的作者应该选择下面两种方式之一来实现它</p>
<ul>
<li>返回一个关于 <code>Measurement</code> 指标 的列表 <em>(或是元祖、生成器、迭代器等)</em></li>
<li>使用一个观察者参数让回调能够独立的报告每个所需的 <code>Measurement</code></li>
</ul>
<p>用户层面的代码不应该在同一个回调的不同 <code>Measurement</code> 指标中提供相同的 <code>Attributes</code> 属性，因为 <code>SDK</code> 针对这种情况可以选择自己的处理方式，比如在回调中返回了两个指标信息 <code>value=3.38, attributes={cpu:1, cpu:2}</code> 以及 <code>value=3.51, attributes={cpu:1, cpu:2}</code>，则 <code>SDK</code> 可以选择直接将他们传递出去 <em>(也就是下游的消费者会处理到相同的信息)</em>，丢弃整个报告信息，取其中最后的那条等等。<code>API</code> 需要对观察过程中来自同一个回调的多个指标作为单独的整体进行记录，比如需要为他们记录相同的时间戳。</p>
<p><code>API</code> 应该提供传递某些 <code>state</code> 状态给回调的方式，<code>OpenTelemetry API</code> 的作者应该自己选择合适的方式。</p>
<p>下面是一些示例</p>
<pre><code class="language-python">def cpu_frequency_callback():
  # Note: in the real world these would be retrieved from the operating system
  return (
    (3.38, (&quot;cpu&quot;, 0), (&quot;core&quot;, 0)),
    (3.51, (&quot;cpu&quot;, 0), (&quot;core&quot;, 1)),    
    (0.57, (&quot;cpu&quot;, 1), (&quot;core&quot;, 0)),
    (0.56, (&quot;cpu&quot;, 1), (&quot;core&quot;, 1)),    
  )

meter.create_observable_gauge(
  name=&quot;cpu.frequency&quot;,
  description=&quot;the real-time CPU clock speed&quot;,
  callback=cpu_frequency_callback,
  unit=&quot;GHz&quot;,
  value_type=float
)
</code></pre>
<pre><code class="language-python">def cpu_frequency_callback(result):
    # Note: in the real world these would be retrieved from the operating system
    result.Observe(3.38, (&quot;cpu&quot;, 0), (&quot;core&quot;, 0))
    result.Observe(3.51, (&quot;cpu&quot;, 0), (&quot;core&quot;, 1))
    result.Observe(0.57, (&quot;cpu&quot;, 1), (&quot;core&quot;, 0))
    result.Observe(0.56, (&quot;cpu&quot;, 1), (&quot;core&quot;, 1))

meter.create_observable_gauge(
    name=&quot;cpu.frequency&quot;,
    description=&quot;the real-time CPU clock speed&quot;,
    callback=cpu_frequency_callback,
    unit=&quot;GHz&quot;,
    value_type=float)
</code></pre>
<h4><a class="header" href="#asynchronous-gauge-operations" id="asynchronous-gauge-operations">Asynchronous Gauge Operations</a></h4>
<p>异步的 <code>Gauge</code> 适用于异步的场景，他唯一提供的操作就是创建 <code>Gauge</code> 时所注册的 <code>callback</code> 回调函数。</p>
<h3><a class="header" href="#updowncounter" id="updowncounter">UpDownCounter</a></h3>
<p><code>UpDownCounter</code> 是一个支持进行递增或递减的同步的 <code>Instrument</code></p>
<blockquote>
<p>即如果对应的值是单调递增的，则应该使用 <a href="7_Metrics_API.html#Counter">Counter</a></p>
</blockquote>
<p>比如下面是几个使用 <code>UpDownCounter</code> 的示例</p>
<ul>
<li>活跃的请求数</li>
<li>在队列中的元素数量</li>
</ul>
<p><code>UpDownCounter</code> 所适合的是具体的值不需要进行预先计算，或是获取当前值时需要付出额外努力的场景，如果预先计算的值已经准备好了，或者是可以很便捷的获取当前值的各个快照，那就应该使用 [Asynchronous UpDownCounter](#Asynchronous Counter) 。</p>
<p>举个获取某个集合的大小作为例子，大部分的编程语言都会提供一个获取集合大小的接口，无论这个接口的功能是直接获取其内部的大小值还是通过某些方式计算出来的，如果这个大小能够直接的从这些接口获取，那就应该使用 [Asynchronous UpDownCounter](#Asynchronous Counter) 了。</p>
<pre><code class="language-python">items = []
meter.create_observable_up_down_counter(
  name=&quot;store.inventory&quot;,
  description=&quot;the number of the items available&quot;,
  callback=lambda result: result.Observe(len(items))
)
</code></pre>
<p>这里还有一个编程语言运行时的接口无法提供充足信息的例子，比如根据颜色跟材质来报告包裹中的分组数量</p>
<table><thead><tr><th>Color</th><th>Material</th><th>Count</th></tr></thead><tbody>
<tr><td>Red</td><td>Aluminum</td><td>1</td></tr>
<tr><td>Red</td><td>Steel</td><td>2</td></tr>
<tr><td>Blue</td><td>Aluminum</td><td>0</td></tr>
<tr><td>Blue</td><td>Steel</td><td>5</td></tr>
<tr><td>Yellow</td><td>Aluminum</td><td>0</td></tr>
<tr><td>Yellow</td><td>Steel</td><td>3</td></tr>
</tbody></table>
<pre><code class="language-python">items_counter = meter.create_up_down_counter(
    name=&quot;store.inventory&quot;,
    description=&quot;the number of the items available&quot;)

def restock_item(color, material):
    inventory.add_item(color=color, material=material)
    items_counter.add(1, {&quot;color&quot;: color, &quot;material&quot;: material})
    return true

def sell_item(color, material):
    succeeded = inventory.take_item(color=color, material=material)
    if succeeded:
        items_counter.add(-1, {&quot;color&quot;: color, &quot;material&quot;: material})
    return succeeded
</code></pre>
<h4><a class="header" href="#updowncounter-creation" id="updowncounter-creation">UpDownCounter Creation</a></h4>
<p><code>UpDownCounter</code> 只能够通过 <code>Meter</code> 来进行创建，创建的接口需要接收下列参数</p>
<ul>
<li><code>Name</code> 参数，遵循 <code>Instrument</code> 命名规范</li>
<li>可选的 <code>Unit</code> 参数，遵循 <code>Instrument</code>单元命名规范</li>
<li>可选的 <code>Description</code> 参数，遵循 <code>Instrument</code> 描述规范</li>
</ul>
<p>下面是创建 <code>UpDownCounter</code> 的示例</p>
<pre><code class="language-python">scustomers_in_store = meter.create_up_down_counter(
  name=&quot;grocery.customers&quot;,
  description=&quot;measures the current customers in the grocery store&quot;,
  value_type=int
)
</code></pre>
<h4><a class="header" href="#updowncounter-operations" id="updowncounter-operations">UpDownCounter Operations</a></h4>
<h5><a class="header" href="#add-1" id="add-1">Add</a></h5>
<p>使用指定的值递增或递减 UpDownCounter，这个接口不会返回任何的结果，他接收下面的参数</p>
<ul>
<li>具体需要增加的值，可以是正数也可以是负数或零</li>
<li>可选的属性</li>
</ul>
<p><code>OpenTelemetry API</code> 的作者应该选择灵活的方式来独立的传递属性参数，下面是一个 <code>OpenTelemetry API</code> 的可以考虑的方式</p>
<pre><code class="language-python">customers_in_store.Add(1, {&quot;account.type&quot;: &quot;commercial&quot;})
customers_in_store.Add(-1, account_type=&quot;residential&quot;)
</code></pre>
<h3><a class="header" href="#asynchronous-updowncounters" id="asynchronous-updowncounters">Asynchronous UpDownCounters</a></h3>
<p>异步的 <code>UpDownCounter</code> 是一个异步的 <code>Instrument</code>，可以在被进行观察的时候报告具有附加性的值 <em>(比如处理堆的大小，因为报告各个堆的大小，然后求他们的总和来表达堆的整体使用状况是有实际意义的)</em>。</p>
<blockquote>
<p>如果值是单调递增的，则应该使用 [Asynchronous Counter](#Asynchronous Counter) ，如果值是不具有附加性的，则应该使用 [Asynchronous Gauge](#Asynchronous Gauge) 。</p>
</blockquote>
<p>下面是使用异步的 <code>UpDownCounter</code> 的场景示例</p>
<ul>
<li>处理的堆尺寸</li>
<li>无锁的循环缓冲区大概的元素数量</li>
</ul>
<h4><a class="header" href="#asynchonous-updowncounter-creation" id="asynchonous-updowncounter-creation">Asynchonous UpDownCounter Creation</a></h4>
<p>异步的 <code>UpDownCounter</code> 允许通过 <code>Meter</code> 来进行创建，可能是使用类似 <code>CreateObservableUpDownCounter</code> 之类的接口。这个接口应该接收下面的参数</p>
<ul>
<li><code>Name</code> 参数，遵循 <code>Instrument</code> 命名规范</li>
<li>可选的 <code>Unit</code> 指标，遵循 <code>Instrument</code> 单元规范</li>
<li>可选的 <code>Description</code> ，遵循 <code>Instrument</code> 描述规范</li>
<li><code>Callback</code> 回调函数</li>
</ul>
<p>回调函数只会在对应的 <code>Meter</code> 被进行观察的时候调用，并需要负责报告所需的指标信息，同时这个回调函数不应该花费不确定的大量的时间，如果运行中的运用中有多个独立的 SDK ，他们之间对这个回调函数的调用也应该是独立的。</p>
<p><code>OpenTelemetry API</code> 的作者应该选择下面两种方式之一来实现它</p>
<ul>
<li>返回一个关于 <code>Measurement</code> 指标 的列表 <em>(或是元祖、生成器、迭代器等)</em></li>
<li>使用一个观察者参数让回调能够独立的报告每个所需的 <code>Measurement</code></li>
</ul>
<p>用户层面的代码不应该在同一个回调的不同 <code>Measurement</code> 指标中提供相同的 <code>Attributes</code> 属性，因为 <code>SDK</code> 针对这种情况可以选择自己的处理方式，比如在回调中返回了两个指标信息 <code>value=1, attributes={pid:4, bitness:64}</code> and <code>value=2, attributes={pid:4, bitness:64}</code>，则 <code>SDK</code> 可以选择直接将他们传递出去 <em>(也就是下游的消费者会处理到相同的信息)</em>，丢弃整个报告信息，取其中最后的那条等等。<code>API</code> 需要对观察过程中来自同一个回调的多个指标作为单独的整体进行记录，比如需要为他们记录相同的时间戳。</p>
<p><code>API</code> 应该提供传递某些 <code>state</code> 状态给回调的方式，<code>OpenTelemetry API</code> 的作者应该自己选择合适的方式。</p>
<p>下面是接口的示例</p>
<pre><code class="language-python">
def ws_callback():
    # Note: in the real world these would be retrieved from the operating system
    return (
        (8,      (&quot;pid&quot;, 0),   (&quot;bitness&quot;, 64)),
        (20,     (&quot;pid&quot;, 4),   (&quot;bitness&quot;, 64)),
        (126032, (&quot;pid&quot;, 880), (&quot;bitness&quot;, 32)),
    )

meter.create_observable_updowncounter(
    name=&quot;process.workingset&quot;,
    description=&quot;process working set&quot;,
    callback=ws_callback,
    unit=&quot;kB&quot;,
    value_type=int)
</code></pre>
<pre><code class="language-python">
def ws_callback(result):
    # Note: in the real world these would be retrieved from the operating system
    result.Observe(8,      (&quot;pid&quot;, 0),   (&quot;bitness&quot;, 64))
    result.Observe(20,     (&quot;pid&quot;, 4),   (&quot;bitness&quot;, 64))
    result.Observe(126032, (&quot;pid&quot;, 880), (&quot;bitness&quot;, 32))

meter.create_observable_updowncounter(
    name=&quot;process.workingset&quot;,
    description=&quot;process working set&quot;,
    callback=ws_callback,
    unit=&quot;kB&quot;,
    value_type=int)
</code></pre>
<h4><a class="header" href="#asynchronous-updowncounter-operations" id="asynchronous-updowncounter-operations">Asynchronous UpDownCounter Operations</a></h4>
<p>异步的 <code>UpDownCounter</code> 适用于异步的场景，他唯一提供的操作就是创建 <code>UpDownCounter</code> 时所注册的 <code>callback</code> 回调函数。</p>
<h2><a class="header" href="#measurement" id="measurement">Measurement</a></h2>
<p><code>Measurement</code> 表示一个通过 指标 <code>API</code> 报告给 <code>SDK</code> 的数据点，具体的信息可以参考 <a href="https://opentelemetry.io/docs/reference/specification/metrics/#programming-model">Metrics Programming Model</a> 。简单来说 <code>Measurements</code> 可以概括为</p>
<ul>
<li>一个值</li>
<li>一系列属性</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
