<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>dict - SinSay's Note Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="tokio.html"><strong aria-hidden="true">1.</strong> Tokio Tutirial</a></li><li><ol class="section"><li><a href="tokio/tokio - tutorial - hello.html"><strong aria-hidden="true">1.1.</strong> Hello</a></li><li><a href="tokio/tokio - tutorial - spawning.html"><strong aria-hidden="true">1.2.</strong> Spawning</a></li></ol></li><li><a href="data_struct.html"><strong aria-hidden="true">2.</strong> DataStruct</a></li><li><ol class="section"><li><a href="redis/sds.html"><strong aria-hidden="true">2.1.</strong> sds</a></li><li><a href="redis/dict.html" class="active"><strong aria-hidden="true">2.2.</strong> dict</a></li><li><a href="redis/skiplist.html"><strong aria-hidden="true">2.3.</strong> skiplist</a></li><li><a href="redis/intset.html"><strong aria-hidden="true">2.4.</strong> intset</a></li><li><a href="redis/ziplist.html"><strong aria-hidden="true">2.5.</strong> ziplist</a></li></ol></li><li><a href="redis.html"><strong aria-hidden="true">3.</strong> Redis</a></li><li><ol class="section"><li><a href="redis/1. Redis 基本定义.html"><strong aria-hidden="true">3.1.</strong> 基本定义</a></li><li><a href="redis/2. Redis 分析起步.html"><strong aria-hidden="true">3.2.</strong> 分析起步</a></li><li><a href="redis/3. Redis 请求处理.html"><strong aria-hidden="true">3.3.</strong> 请求处理</a></li><li><a href="redis/4. Redis 执行命令.html"><strong aria-hidden="true">3.4.</strong> 执行命令</a></li></ol></li><li><a href="distributed.html"><strong aria-hidden="true">4.</strong> Distributed</a></li><li><ol class="section"><li><a href="distributed/mapreduce_note.html"><strong aria-hidden="true">4.1.</strong> MapReduce</a></li><li><a href="distributed/raft_note.html"><strong aria-hidden="true">4.2.</strong> Raft</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">SinSay's Note Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="redis/dict.html#a字典" id="a字典"><h1>字典</h1></a>
<p>[TOC]</p>
<a class="header" href="redis/dict.html#a简介" id="a简介"><h2>简介</h2></a>
<p>字典是用来存储键值对的结构，亦即是他允许使用一个 <code>键</code> 来查找对应的 <code>值</code>，为什么需要把查找的依据跟需要的数据分开呢，因为 <code>值</code> 有可能会是一个非常复杂的结构，而 <code>键</code> 一般是从 <code>值</code> 推导出来的一个较为简单的表示方式。</p>
<p>字典也称哈希表，因为他主要是以各种 <code>哈希函数</code> 对 <code>键</code> 进行计算，并得到 一个唯一的 <strong>索引</strong>，来指向对应的 <code>值</code>。</p>
<blockquote>
<a class="header" href="redis/dict.html#a哈希-hash" id="a哈希-hash"><h3>哈希 (Hash)</h3></a>
<p><strong><em>哈希函数</em></strong>
哈希函数是指一类函数，他会将输入的参数进行一系列运算，并得出一个唯一的结果，一个设计良好的哈希函数能够从不同的参数得出不同的结果，并且这个结果将平均分布在样本空间中，如果将计算结果当成一个点，所有可能的结果集当成平面上的一个圆，那这些点将会平均的分布在这个圆上的各个地方。</p>
<p><strong><em>时间复杂度</em></strong>
因为字典的查找在正常情况下，都只消耗跟 哈希 函数对应的时间，所以我们确定它是可以在常数时间，也就是 O(1) 得到结果的。</p>
<p><strong><em>碰撞</em></strong>
有时候 哈希 函数根据 <code>键</code> 计算出来的索引不一定是唯一的，这个时候就会产生碰撞，也就是两个不同的 <code>键</code> 会指向同一个索引，这时有很多种方式来解决这个碰撞问题，如开地址法，链表法等，我们这里的实现只会介绍链表法。</p>
</blockquote>
<p>这里进行分析的是 Redis 源码中的 Dict 实现，他较之正常定义的字典来说，主要是增加了自动扩展机制，使用了二重字典，在字典的负载超过阀值之后，就会以渐进的方式逐步将字典的内容扩展到一个新的字典中。</p>
<a class="header" href="redis/dict.html#a实现" id="a实现"><h2>实现</h2></a>
<a class="header" href="redis/dict.html#a字典的定义" id="a字典的定义"><h3>字典的定义</h3></a>
<div id="dictDefine" ></div>
``` c
<p>// 定义了两个宏，用来表示字典的状态
#define DICT_OK  0
#define DICT_ERR 1</p>
<p>// hash 后的 字典项
// key 保存了用以查找该项的依据
// v 是保存的值
// next 则是前面说的链表法的实现，
// 当有碰撞时则将 hash 结果相同的项连接成一个链表
typedef struct dictEntry {
void *key;
union {
void *val;
uint64_t u64;
int64_t s64;
double d;
} v;
struct dictEntry *next;
} dictEntry;</p>
<p>// dictType 保存了当前字典的信息，包括了 Hash 函数的具体实现
// 以及 <code>键</code> 跟 <code>值</code> 的比较、复制跟销毁方式
typedef struct dictType {
unsigned int (*hashFunction)(const void *key);
void *(*keyDup)(void *privdata, const void *key);
void *(*valDup)(void *privdata, const void *key);
int (*keyCompare)(void *privdata, const void *key1, const void *key2);
void (*keyDestructor)(void *privdata, const void *key);
void (*valDestructor)(void *privdata, const void *key);
} dictType;</p>
<p>// 这个是确切的 哈希表，也就是字典的实现，
// 保存了字典的尺寸、使用量等
typedef struct dictht {
dictEntry **table;
unsigned long size;
unsigned long sizemask;
unsigend long used;
} dictht;</p>
<p>// 字典对外公开的结构，其中即包含了用于重新扩展字典的标志信息:
// rehashidx
typedef struct dict {
dictType *type;
void *privdata;
dictht ht[2];
long rehashidx;
int iterators;
} dict;</p>
<pre><code>
上面是跟字典相关的所有结构的定义，我们也大致说明了各个字段的意义。
基本上就是 dictht 是每个确切的 hash 表，而 dict 管理了两个 dictht，对他们进行了一个更上层的管理，如 Rehashing 机制。
接下来看看具体的实现，首先看看如何创建一个字典。

### 乱入的字典说明
由上面的结构定义我们能看到，Redis 的实现使用了 dict 来管理两个 dictht。
一般的字典实现是：
    
    * 创建 Hash 表
    * 增加元素
        * 对 Key Hash, 得到索引
        * 在指定的索引插入新元素
        * 如果有冲突，则使用各种冲突解决方案
    * 查找元素
        * 对要查找的 Key 进行 Hash，得到索引
        * 在对应的索引位置查找需要的元素

Reids 的 dict 则将这些操作再次进行了包装，以满足再字典接近满负荷时，可以平滑的进行扩展，这个扩展的机制即是上面说过的 **Rehashing**

* 它使用了两个 `dictdt`, 并使用了 `reashidx` 来管理当前使用的 `dictdt`
* 当使用中的 `dictdt` 达到负荷条件时，则启动 `Rehashing` 机制
    * 将新的数据插入到另一个 `dictdt`
    * 并分批将旧的数据从原有的 `dictdt` 中移到新的 `dictht`。


所以在下文中，我们会经常看到 isRehashing 这个函数，它是用来判断当前 `dict` 是否正在进行 `Rehashing`，如果是的话则启动分批处理函数处理旧数据，并提示其他操作都要在新的 `dictht` 中进行。


### 创建字典 (dictCreate)
创建一个字典的时候需要提供两个参数。

 * 一个字典类型的定义，其中包括了如何对 `键` 进行哈希，`建` 跟 `值` 的复制、比较以及销毁，具体定义可见 [dictType](#dictDefine) 的定义.
 * 一个私有数据：`privDataPtr`, 这个私有数据字典本身并不会用到，提供它的原因是为了字典类型的各个操作，当他们之间需要维护状态或者通信等操作时可以使用

``` c 
dict *dictCreate(dictType *type, void privDataPrt) {
    dict *d = zmalloc(sizeof(*d));
    
    _dictInit(d, type, privDataPtr);
    return d;
}

int _dictInit(dict *d, dictType *type, void *privDataPtr) {
    // 首先重置当前字典的两个内置哈希表
    _dictReset(&amp;d-&gt;ht[0]);
    _dictReset(&amp;d-&gt;ht[1]);
    d-&gt;type = type;
    d-&gt;privdata = privDataPtr;
    d-&gt;rehashidx = -1;
    d-&gt;iterators = 0;
    return DICT_OK;
}
</code></pre>
<p>以上字典的初始化，主要是在 _dictInit 中实现，其中包括了重置字典的状态，初始化各个字段</p>
<ul>
<li>type 保存了字典的类型</li>
<li>privdata 保存了私有数据</li>
<li>rehashidx 保存了字典当前的扩展状态，如果值为 -1 说明当前没有在进行扩展</li>
<li>iterators 则保存了迭代器信息</li>
</ul>
<p>而 _dictReset 则设置各个字段的初始值。</p>
<pre><code class="language-c">static void _dictReset(dictht *ht) {
    ht-&gt;table = NULL;
    ht-&gt;size = 0;
    ht-&gt;sizemask = 0;
    ht-&gt;used = 0;
}
</code></pre>
<a class="header" href="redis/dict.html#a添加一个键值-dictadd" id="a添加一个键值-dictadd"><h3>添加一个键值 (dictAdd)</h3></a>
<p>接下来是往字典中添加一个项，也就是添加一个 <code>键</code> 跟其对应的 <code>值</code>。
测试代码如下：</p>
<pre><code class="language-c">// 这里我们使用了之前介绍过的 sds 模块，用他来保存我们的键值
// dictType = ...
dict *c = dictCreate(dtype, NULL);
sds *key = sdsnew(&quot;hello&quot;);
sds *val = sdsnew(&quot;world&quot;);

if (DICT_OK == dictAdd(d, key, val)) {
    // add kv ok
}
</code></pre>
<p>以上的测试代码中，首先新建了一个字典，然后分别使用 sds 来表示对应的 key 跟 value，然后将其加入字典中。
然后我们看看 dictAdd 的具体实现</p>
<pre><code class="language-c">int dictAdd(dict *d, void *key, void *val) {
    dictEntry *entry = dictAddRaw(d, key);
    if (!entry) return DICT_ERR;
    dictSetVal(d, entry, val);
    return DICT_OK;
}
</code></pre>
<p>所有的功能基本都是调用其他的内部接口，我们继续看内部的实现。
首先是 <code>dictAddRaw</code>, 它是根据 key 计算出其对应的索引值，并判断 key 是否已经存在于字典中，如果已经存在，则不做任何事情，如果不存在则返回对应的索引，然后才往字典中进行添加。</p>
<pre><code class="language-c">dictEntry *dictAddRaw(dict *d, void *key) {
    int index;
    dictEntry *entry;
    dictht *ht;
    
    // 这一步是用来扩展字典的，我们留到后面的章节来进行说明
    if (dictIsRehashing(d)) _dictRehashStep(d);
    
    // 如果 key 已经在字典中存在，则直接返回 NULL
    if ((index = _dictKeyIndex(d, key)) == -1)
        return NULL;
        
    // 接着添加一个新的节点用来存放新的字典项
    // 首先是获取当前可以插入数据的 dictht
    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];
    entry = zmalloc(sizeof(*entry));
    // 将新的节点设为头节点，旧有的链表则作为新节点的后续节点
    entry-&gt;next = ht-&gt;table[index];
    ht-&gt;table[index] = entry;
    // 添加已有节点数
    ht-&gt;used++;
    
    // 设置新节点的 key 字段，这里的 dictSetKey 是个宏，作用是
    // 如果 字典类型指定了 key 的复制方式，则使用指定的复制方式，
    // 否则直接复制 key 的指针
    dictSetKey(d, entry, key);
    return entry;
}

</code></pre>
<p>上面很多步骤都包含了 dictIsRehashing 的调用，它用来判断当前字典是否正在扩展，具体如何扩展，我们留到后续的章节说明。
接着再继续看看 _dictKeyIndex 是如何获取 key 对应的索引值的</p>
<pre><code class="language-c">static int _dictKeyIndex(dict *d, const void *key) {
    unsigned int h, idx, table;
    dictEntry *he;
    
    // 判断字典是否需要扩展
    if (_dictExpandIfNeeded(d) == DICT_ERR)
        return -1;
        
    h = dictHashKey(d, key); // 计算 key 对应的索引值
    for (table = 0; table &lt;= 1; table++) {
        idx = h &amp; d-&gt;ht[table].sizemask;
        he = d-&gt;ht[table].table[idx];
        while (he) {
            if (dictCompareKeys(d, key, he-&gt;key))
                return -1;
            he = he-&gt;next;
        }
        if (!dictIsRehashing(d)) break;
    }
    return idx;
}
</code></pre>
<p>重点只有两处</p>
<ul>
<li>第一处是 dictHashKey 的实现，不过因为 <code>字典</code> 已经把 hash 的实现方式丢给了调用方，所以它这里只是单纯的转调 <code>dictType</code> 中的 <code>hashFunction</code>，具体的 hash 是怎么做的这里就不详细讨论了，最后会附上 Redis 使用的 HashFunction</li>
<li>第二处则是 for 循环，而 for 循环的重点则是查找两个 dictht，在指定的索引中寻找空位供新的元素插入。</li>
</ul>
<p>然后附上 <code>dictSetKey</code> 的宏定义</p>
<pre><code class="language-c">#define dictSetKey(d, entry, _key_) do { \
    if ((d)-&gt;type-&gt;keyDup) \
        entry-&gt;key = (d)-&gt;type-&gt;keyDup((d)-&gt;privdata, _key_); \
    else \
        entry-&gt;key = (_key_); \
} while(0)
</code></pre>
<a class="header" href="redis/dict.html#a查找一个键值" id="a查找一个键值"><h3>查找一个键值</h3></a>
<p>在上面的示例代码中，我们往其中插入了元素之后，想根据 Key 来获取对应的 Value，则可以如下般调用</p>
<pre><code class="language-c">sds key = sdsnew(&quot;hello&quot;);

dictEntry *val = dictFind(c, key);
// 得到 dictEntry 后，即可从 v 字段得到所需的 value
printf(&quot;%s\n&quot;, (sds)val-&gt;v);

</code></pre>
<p>具体的实现很简单，其实就是一个插入新元素的过程，并且比插入元素还要简单得多，
首先计算 key 的 hash 值，得到其在 table 中对应的索引，然后遍历对应索引上的链表，逐一进行比较。</p>
<pre><code class="language-c">dictEntry *dictFind(dict *d, const void *key) {
    dictEntry *he;
    unsigned int h, idx, table;
    
    // 如果 dict 为空，则直接返回 NULL
    if (d-&gt;ht[0].size == 0) return NULL;

    // Rehashing 判断，下面章节会有详细说明
    if (dictIsRehashing(d)) _dictRehashStep(d);
    
    // 计算 key 对应的 hash 值
    h = dictHashKey(d, key);
    // 在有必要的情况下遍历两个 table, 这里的必要指的就是在 Rehashing 的情况下
    for (table = 0; table &lt;= 1; table++) {
        // 根据当前 table 的尺寸进行取余
        idx = h &amp; d-&gt;ht[table].sizemask;
        // 得到对应的元素链表
        he = d-&gt;ht[table].table[idx];
        // 逐一进行比较，如果找到则返回对应的 dictEntry
        while (he) {
            if (dictCompareKeys(d, key, he-&gt;key))
                return he;
            he = he-&gt;next;
        }
        // 只有正在进行 Rehashing 的情况下，才有必要再检查 ht[1]
        if (!dictIsRehashing(d)) return NULL;
    }
}
</code></pre>
<a class="header" href="redis/dict.html#a删除一个键值" id="a删除一个键值"><h3>删除一个键值</h3></a>
<p>删除的步骤也与查找跟插入类似，这里不再详说。</p>
<pre><code class="language-c">int dictDelete(dict *ht, const void *key) {
    return dictGenericDelete(ht, key, 0);
}

static int dictGenericDelete(dict *d, const void *key, int nofree) {
    unsigned int h, idx;
    dictEntry *he, *prevHe;
    int table;
    
    if (d-&gt;ht[0].size == 0) return DICT_ERR;
    if (dictIsRehashing(d)) _dictRehashStep(d);
    
    h = dictHashKey(d, key);
    
    for (table = 0; table &lt;= 1; table++) {
        idx = h &amp; d-&gt;ht[table].sizemask;
        he = d-&gt;ht[table].table[idx];
        prevHe = NULL;
        
        while (he) {
            if (dictCompareKeys(d, key, he-&gt;key)) {
                if (prevHe)
                    prevHe-&gt;next = he-&gt;next;
                else
                    d-&gt;ht[table].table[idx] = he-&gt;next;
                    
                if (!nofree) {
                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                }
                zfree(he);
                d-&gt;ht[table].used--;
                return DICT_OK;
            }
            prevHe = he;
            he = he-&gt;next;
        }
        if (!dictIsRehashing(d)) break;
    }
    return DICT_ERR;
}
</code></pre>
<a class="header" href="redis/dict.html#rehashing-的实现" id="rehashing-的实现"><h3>Rehashing 的实现</h3></a>
<p>在上面已经大致讲过了 Rehashing 的机制，也看到了在添加元素时，会调用对应的函数对 <code>dictht</code> 进行 Rehashing, 所以马上我们就来分析下具体的实现。</p>
<a class="header" href="redis/dict.html#a判断状态" id="a判断状态"><h4>判断状态</h4></a>
<p>首先是判断是否正在进行 <code>Rehashing</code></p>
<pre><code class="language-c">#define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)
</code></pre>
<p>直接判断 rehashidx 这个字段是否为 -1，如果正在 Rehashing，则 该字段则<em>不等于</em> -1</p>
<a class="header" href="redis/dict.html#a何时进行-rehashing" id="a何时进行-rehashing"><h4>何时进行 Rehashing</h4></a>
<p>那什么时候会导致这个字段改变呢？也就是说，什么时候会导致 dict 需要进行 <code>Rehashing</code>，回忆上面的 <code>_dictKeyIndex</code>, 里面包含了：</p>
<pre><code class="language-c">static int _dictKeyIndex(dict *d, const void *key) {
    // ...
    if (_dictExpandIfNeeded(d) == DICT_ERR)
    // ...
}
</code></pre>
<p><code>_dictExpandIfNeeded</code> 即根据 dict 的当前状态进行了判断，从而设置了该 rehashidx 字段。
接下来看看判断的具体逻辑</p>
<pre><code class="language-c">static int _dictExpandIfNeeded(dict *d) {
    // 如果正在进行，则直接返回 OK
    if (dictIsRehashing(d)) return DICT_OK;
    
    // 如果当前 dictht 为空，则已默认的大小 (4) 对其进行初始化
    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);
    
    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp;
        (dict_can_resize ||
         d-&gt;ht[0].used / d-&gt;ht[0].size &gt; dict_force_resize_ratio) {
        return dictExpand(d, d-&gt;ht[0].used * 2);   
     }
     return DICT_OK;
}
</code></pre>
<p>最后一个判断条件比较复杂，我们在这边进行解释:</p>
<blockquote>
<p>首先要注意的是 dict_can_resize 这个标志，如果禁止了该标志，则只有当 <code>used</code> 是     <code>size</code> 的 <code>dict_force_resize_ratio</code> 倍时才会进行 <code>Rehashing</code>.
否则只要 <code>used</code> 大于 <code>size</code>, 也就是使用率大于 1,即会开始进行 <code>Rehashing</code></p>
</blockquote>
<p>然后我们可以看到，满足条件后会直接进入 <code>dictExpand</code> 这个调用。
该函数主要是根据当前 <code>dict</code> 的尺寸选择扩张的大小，并为将要使用的 <code>dictht</code> 进行初始化、分配内存等操作，最后则将 <code>rehashidx</code> 这个标志置为 0.
这个 0 表示的意思是，从需要 Rehashing 的 <code>dictht</code> 的第 0 个槽开始操作，所以只要不是 -1,它就表示当前正在处理的位置。</p>
<pre><code class="language-c">int dictExpand(dict *d, unsigned long size) {
    dictht n;
    // 选择将要扩张的尺寸，策略是扩张到下一个大于 size 的基于 2 的倍数的尺寸
    unsigned long realsize = _dictNextPower(size);    
    
    // 如果已经在 Reashing 或者 dictht 的尺寸不合法，则返回错误
    if (dictIsRehashing(d) || d-&gt;ht[0].used &gt; size)
        return DICT_ERR;
        
    // 如果要扩张的尺寸等于当前尺寸（如已经满负荷，达到了 LONG_MAX) 则返回错误
    if (realsize == d-&gt;ht[0].size) return DICT_ERR;
    
    n.size = realsize;
    n.sizemask = realsize - 1;
    n.table = zcalloc(realsize * sizeof(dictEntry*));
    n.used = 0;
    
    // 如果是第一次扩张，也就是 dict 还没有使用过，则直接设置使用新的 dictht
    if (d-&gt;ht[0].table == NULL) {
        d-&gt;ht[0] = n;
        return DICT_OK;
    }
    
    // 否则设置为需要 Rehashing, 并设置新的 dictht
    d-&gt;ht[1] = n;
    d-&gt;rehashidx = 0;
    return DICT_OK;
    
}
    
static unsigned long _dictNextPower(unsigned long size) {
    unsigned long i = DICT_HT_INITIAL_SIZE;
        
    if (size &gt;= LONG_MAX) return LONG_MAX;
    while (1) {
        if (i &gt;= size)
            return i;
        i *= 2;
    }
}

</code></pre>
<a class="header" href="redis/dict.html#a如何-rehashing" id="a如何-rehashing"><h4>如何 Rehashing</h4></a>
<p>当当前 <code>dict</code> 进入 <code>Rehashing</code> 状态后，每次对 <code>dict</code> 进行操作时都会进入 <code>_dictRehashStep</code>，这里会先判断当前是否有操作在迭代 <code>dict</code>，如果没有的话，则进入 <code>Rehashing</code> 的操作。</p>
<p>Rehashing 的具体操作为：</p>
<ul>
<li>默认执行 10 次</li>
<li>每次遍历一个 hash 槽</li>
<li>将旧的数据导到新的 <code>dictht</code></li>
<li>更新 rehashidx 指向下一个需要更新的 <code>dictht.table</code></li>
</ul>
<pre><code class="language-c">static void _dictRehashStep(dict *d) {
    if (d-&gt;iterators == 0) dictRehash(d, 1);
}

// n 是指要 rehash 的次数，每次都会尝试从原有的 dictht 中导入 10 条数据到新的 dictht
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10;
    if (!dictIsRehashing(d)) return 0;
    
    while (n-- &amp;&amp; d-&gt;ht[0].used != 0) {
        dictEntry *de, *nextde;
        
        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);
        
        while (d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) {
            d-&gt;rehashidx++;
            if (--empty_visits == 0) return1;
        }
        // 找到需要转移的槽
        de = d-&gt;ht[0].table[d-&gt;rehashidx];
        
        while (de) {
            unsigned int h;
            nextde = de-&gt;next;
            // 计算就有元素在新的 dictht 中的位置
            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;
            // 重新连接冲突链表
            de-&gt;next = d-&gt;ht[1].table[h];
            d-&gt;ht[1].table[h] = de;
            d-&gt;ht[0].used--;
            d-&gt;ht[1].used++;
            de = nextde;
        }
        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;
        d-&gt;rehashidx++;
    }
    
    // 如果旧有 ht 已经清空，将新的 ht 移到 dict-&gt;ht[0]
    // 并标志 Rehashing 已完成
    if (d-&gt;ht[0].used == 0) {
        zfree(d-&gt;ht[0].table);
        d-&gt;ht[0] = d-&gt;ht[1];
        _dictReset(&amp;d-&gt;ht[1]);
        d-&gt;rehashidx = -1;
        return 0;
    }
    
    // 说明 Rehashing 还未完成
    return 1;
}
</code></pre>
<a class="header" href="redis/dict.html#a遍历字典" id="a遍历字典"><h3>遍历字典</h3></a>
<a class="header" href="redis/dict.html#a迭代器定义" id="a迭代器定义"><h4>迭代器定义</h4></a>
<p>首先看看迭代器的定义</p>
<ul>
<li><code>d</code> 是一个指向需要迭代的 <code>dict</code> 的指针，</li>
<li><code>index</code> 就是迭代器的当前位置</li>
<li><code>table</code> 是当前遍历使用的 <code>dictht</code></li>
<li><code>safe</code> 用来说明当前迭代器使用期间，不允许进行 Rehashing</li>
<li><code>entry</code> 是当前正在迭代的元素</li>
<li><code>nextEntry</code> 是下一个要迭代的元素，为了能够安全的迭代到下一个元素，因为使用者可能会删除当前元素</li>
</ul>
<pre><code class="language-c">typedef struct dictIterator {
    dict *d;
    long index;
    int table, safe;
    dictEntry *entry; *nextEntry;
    // unsafe iterator fingerprint for misuse detection;
    // 用以判断 迭代器 的安全性
    long long fingerprint;
} dictIterator;
</code></pre>
<a class="header" href="redis/dict.html#a获取迭代器" id="a获取迭代器"><h4>获取迭代器</h4></a>
<a class="header" href="redis/dict.html#a获取普通迭代器" id="a获取普通迭代器"><h5>获取普通迭代器</h5></a>
<p>普通的迭代器说明当前迭代器使用期间，<code>dict</code> 有可能被纂改。</p>
<pre><code class="language-c">dictIterator *dictGetIterator(dict *d) {
    dictIterator *iter = zmalloc(sizeof(*iter));
    
    iter-&gt;d = d;
    iter-&gt;table = 0;
    iter-&gt;index = -1;
    iter-&gt;safe = 0;
    iter-&gt;entry = NULL;
    iter-&gt;nextEntry = NULL;
    return iter;
}
</code></pre>
<a class="header" href="redis/dict.html#a获取安全迭代器" id="a获取安全迭代器"><h5>获取安全迭代器</h5></a>
<p>安全迭代器跟普通迭代器的区别只有 <code>safe</code> 字段，并保证使用期间不会进行 <code>Rehashing</code></p>
<pre><code class="language-c">dictIterator *dictGetSafeIterator(dict *d) {
    dictIterator *i = dictGetIterator(d);
    i-&gt;safe = 1;
    return i;
}
</code></pre>
<a class="header" href="redis/dict.html#a遍历迭代器" id="a遍历迭代器"><h4>遍历迭代器</h4></a>
<p><code>dict</code> 提供了迭代器机制，以便对其中的元素进行遍历的。具体的使用只需如一个循环般，一直调用 <code>dictNext</code> 直到返回 NULL 即可。</p>
<pre><code class="language-c">dictEntry *dictNext(dictIterator *iter) {
    while (1) {
        
        if (iter-&gt;entry == NULL) {
            // 如果第一次调用 dictNext, 则初始化对应的标志
            dictht = *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];
            if (iter-&gt;index == -1 &amp;&amp; iter-&gt;table == 0) {
                if (iter-&gt;safe)
                    iter-&gt;d-&gt;iterators++;
                else
                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);
            }
            // 更新指向下一个元素的索引
            iter-&gt;index++;
            
            // 如果超过了当前 ht 的尺寸，则判断是否正在 Rehashing，是的话，切换到新的
            // ht，因为新元素不会在插入到原有的 ht[0]
            if (iter-&gt;index &gt;= (long)ht-&gt;size) {
                if (dictIsRehashing(iter-&gt;d)) &amp;&amp; iter-&gt;table == 0) {
                    iter-&gt;table++;
                    iter-&gt;index = 0;
                    ht = &amp;iter-&gt;d-&gt;ht[1];
                }
                else { // 到这里说明已经迭代到最后了
                    break;
                }
            }            
            iter-&gt;entry - ht-&gt;table[iter-&gt;index];
        }
        else {
            // 如果当前槽仍有元素，则指向下一个
            iter-&gt;entry = iter-&gt;nextEntry;
        }
                   
        // 如果当前元素不为空，则返回给用户，并准备好下一个 
        if (iter-&gt;entry) {
            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;
            return iter-&gt;entry;
        }
    }
    return NULL;
}
</code></pre>
<a class="header" href="redis/dict.html#a释放迭代器" id="a释放迭代器"><h5>释放迭代器</h5></a>
<p>迭代器用完了就得释放，特别是对于安全迭代器，因为他会导致 Rehashing 无法执行（除非是 Dict 严重超负荷：5倍）</p>
<pre><code class="language-c">void dictReleaseIterator(dictIterator *iter) {
    if (!(iter-&gt;index == -1 &amp;&amp; iter-&gt;table ==0)) {
        if (iter-&gt;safe)
            iter-&gt;d-&gt;iterators--;
        else
            assert(iter-&gt;fingerprint == dictFingetprint(iter-&gt;d));
    }
    zfree(iter);
}
</code></pre>
<a class="header" href="redis/dict.html#a指纹验证" id="a指纹验证"><h5>指纹验证</h5></a>
<p>最后一提的是，在上面我们看到了 <code>dictFingerprint</code> 这个调用，能够为 <code>dict</code> 的当前状态生成一个指纹，并且在上面的普通迭代器中也保存了遍历开始时的指纹，这个指纹是用来保证，在遍历时用户没有对 <code>dict</code> 进行了非法的操作，比如删除元素或者增加元素。
具体的实现就不说明了。</p>
<pre><code class="language-c">long long dictFingerprint(dict *d) {
    long long integers[6], hash = 0;
    int j;
    
    iteragers[0] = (long)d-&gt;ht[0].table;
    iteragers[1] = d-&gt;ht[0].size;
    iteragers[2] = d-&gt;ht[0].used;
    iteragers[3] = (long)d-&gt;ht[1].table;
    iteragers[4] = d-&gt;ht[1].size;
    iteragers[5] = d-&gt;ht[1].used;
    
    for (j = 0; j &lt; 6; j++) {
        hash += iteraters[j];
        
        hash = (~hash) + (hash &lt;&lt; 21);
        hash = hash ^ (hash &gt;&gt; 24);
        hash = (hash + (hash &lt;&lt; 3)) + (hash &lt;&lt; 8); // hash * 265
        hash = hash ^ (hash &gt;&gt; 14);
        hash = (hash + (hash &lt;&lt; 2)) + (hash &lt;&lt; 4); // hash * 21
        hash = hash ^ (hash &gt;&gt; 28);
        hash = hash + (hash &lt;&lt; 31);
    }
    return hash;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="redis/sds.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="redis/skiplist.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="redis/sds.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="redis/skiplist.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
