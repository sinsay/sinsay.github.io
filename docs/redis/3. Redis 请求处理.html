<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3. 请求处理 - SinSay's Note Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="about.html"><strong aria-hidden="true">1.</strong> About Me</a></li><li><a href="tokio.html"><strong aria-hidden="true">2.</strong> Tokio Tutirial</a></li><li><ol class="section"><li><a href="tokio/tokio - tutorial - hello.html"><strong aria-hidden="true">2.1.</strong> Hello</a></li><li><a href="tokio/tokio - tutorial - spawning.html"><strong aria-hidden="true">2.2.</strong> Spawning</a></li><li><a href="tokio/tokio - tutorial - shared state.html"><strong aria-hidden="true">2.3.</strong> Shared State</a></li><li><a href="tokio/tokio - tutorial - channel.html"><strong aria-hidden="true">2.4.</strong> Channel</a></li><li><a href="tokio/tokio - tutorial - io.html"><strong aria-hidden="true">2.5.</strong> I/O</a></li><li><a href="tokio/tokio - tutorial - framing.html"><strong aria-hidden="true">2.6.</strong> Framing</a></li></ol></li><li><a href="data_struct.html"><strong aria-hidden="true">3.</strong> DataStruct</a></li><li><ol class="section"><li><a href="redis/sds.html"><strong aria-hidden="true">3.1.</strong> sds</a></li><li><a href="redis/dict.html"><strong aria-hidden="true">3.2.</strong> dict</a></li><li><a href="redis/skiplist.html"><strong aria-hidden="true">3.3.</strong> skiplist</a></li><li><a href="redis/intset.html"><strong aria-hidden="true">3.4.</strong> intset</a></li><li><a href="redis/ziplist.html"><strong aria-hidden="true">3.5.</strong> ziplist</a></li></ol></li><li><a href="redis.html"><strong aria-hidden="true">4.</strong> Redis</a></li><li><ol class="section"><li><a href="redis/1. Redis 基本定义.html"><strong aria-hidden="true">4.1.</strong> 基本定义</a></li><li><a href="redis/2. Redis 分析起步.html"><strong aria-hidden="true">4.2.</strong> 分析起步</a></li><li><a href="redis/3. Redis 请求处理.html" class="active"><strong aria-hidden="true">4.3.</strong> 请求处理</a></li><li><a href="redis/4. Redis 执行命令.html"><strong aria-hidden="true">4.4.</strong> 执行命令</a></li></ol></li><li><a href="distributed.html"><strong aria-hidden="true">5.</strong> Distributed</a></li><li><ol class="section"><li><a href="distributed/mapreduce_note.html"><strong aria-hidden="true">5.1.</strong> MapReduce</a></li><li><a href="distributed/raft_note.html"><strong aria-hidden="true">5.2.</strong> Raft</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">SinSay's Note Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="redis/3. Redis 请求处理.html#redis-内容篇" id="redis-内容篇"><h1>Redis 内容篇</h1></a>
<p>[TOC]</p>
<a class="header" href="redis/3. Redis 请求处理.html#a解析请求" id="a解析请求"><h2>解析请求</h2></a>
<p>在前文我们看到了当客户端发送命令过来时，是由 <code>ae</code> 调用 <code>readQueryFromClient</code> 进行处理，接着我们来看看这个函数是如何处理客户端发送过来的数据的。</p>
<pre><code class="language-c">void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {
    int nread, readlen;
    size_t qblen;
    REDIS_NOTUSED(el);
    REDIS_NOTUSED(mask);

    server.current_client = c;
    readlen = REDIS_IOBUF_LEN;

    // 处理大数据包
    if (c-&gt;reqtype == REDIS_REQ_MULTIBULD &amp;&amp; c-&gt;multibulklen &amp;&amp;
         c-&gt;bulklen != -1 &amp;&amp; c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG) {
        int remaining = (unsigned)(c-&gt;bulklen + 2) - sdslen(c-&gt;querybuf);
        // 如果剩余的数据量少于默认的缓存数，则使用较小的缓存大小
        if (remaining &lt; readlen) readlen = remaining;
    }

    qblen = sdslen(c-&gt;querybuf);
    if (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peek = qblen;
    // 扩展缓存空间，以存放即将读取的数据
    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);
    // c-&gt;querybuf + qblen 是跳过已经使用的缓存内容
    nread = read(fd, c-&gt;querybuf + qblen, readlen);

    // 错误处理，如果因为信号中断，则设置 nread 为 0，并等待下次重读
    // 如果远程客户端断开，则服务端也断开连接
    if (nread == -1) {
        if (errno == EAGAIN) {
            nread = 0;
        }
        else {
            readLog(REDIS_VERBOSE, &quot;Reading from client: %s&quot;, strerrno(errno));
            freeClient(c);
            return;
        }
    }
    else if(nread == 0) {
        readisLog(REDIS_VERBOSE, &quot;Client closed connection&quot;);
        freeClient(c);
        return;
    }

    if (nread) {
        // 调整 querybuf 已使用的数据量
        sdsIncrLen(c-&gt;querybuf, nread);
        // 更新状态信息
        c-&gt;lastinteraction = server.unixtime;
        if (c-&gt;flags &amp; REDIS_MASTER) c-&gt;reploff += nread;
        server.stat_net_input_bytes += nread;
    }
    else {
        server.current_client = NULL;
        return;
    }

    // 如果当前客户端请求的缓存大于系统设置的上限，则中断此连接, 并输出当前连接信息
    // 比如当前客户端是攻击者？
    if (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) {
        sds ci = catClientInfoString(sdsempty(), c), bytes = sdsempty();
        bytes = sdscatrepr(bytes, c-&gt;querybuf, 64);
        redisLog(REDIS_WARNING, &quot;Closing client that reached max query buffer length&quot;);
        sdsfree(ci);
        sdsfree(bytes);
        freeClient(c);
        return;
    }

    // 开始处理请求
    processInputBuffer(c);
    server.current_client = NULL;
}
</code></pre>
<p>上面使用了最正统的 socket 处理方式，读取数据，做出错误处理，验证客户端的安全性（缓存长度），然后把接收到的数据丢给 <code>processInputBuffer</code> 进行处理。
接下来我们看看它是怎么做的。</p>
<pre><code class="language-c">void processInputBuffer(redisClient *c) {
    // 处理直到 buf 中没有数据
    while (sdslen(c-&gt;querybuf)) {

        // 如果是从服务器，并且由于某些原因处于暂停状态，则不处理客户端的命令
        if (!(c-&gt;flags &amp; REDIS_SLAVE) &amp;&amp; clientsArePaused()) return;

        // 如果当前客户端正在某个处理步骤的中间，则不处理命令
        if (c-&gt;flags &amp; REDIS_BLOCKED) return;

        // 如果当前客户端在回复后就要关闭，则不处理命令
        if (c-&gt;flags &amp; REDIS_CLOSE_AFTER_REPLY) return;

        // 确认当前客户端的请求模式, 单行或多行模式
        if (!c-&gt;reqtype) {
            if (c-&gt;querybuf[0] == '*') {
                c-&gt;reqtype = REDIS_REQ_MULTIBULK;
            }
            else {
                c-&gt;reqtype = REDIS_REQ_INLINE;
            }
        }

        // 然后再根据模式处理接收到的数据
        if (c-&gt;reqtype == REDIS_REQ_INLINE) {
            if (processInlineBuffer(c) != REDIS_OK) break;
        }
        else if(c-&gt;reqtype == REDIS_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != REDIS_OK) break;
        }
        else {
            redisPanic(&quot;Unknown request type&quot;);
        }

        // 如果是 Multibulk 模式，则可能会出现 argc &lt;= 0 的情况
        if (c-&gt;argc == 0) {
            resetClient(c);
        }
        else {
            // 开始处理命令
            if (processCommand(c) == REDIS_OK)
                resetClient(c);
        }
    }
}
</code></pre>
<p>在进入处理具体命令的逻辑之前，我们先看看，是如何组织命令信息的，Inline 跟 MultiBulk 两种方式分别实现在 <code>processInlineBuffer</code> 跟 <code>processMultibulkBuffer</code> 中，我们分别来看看。</p>
<a class="header" href="redis/3. Redis 请求处理.html#a解析单个命令请求" id="a解析单个命令请求"><h3>解析单个命令请求</h3></a>
<pre><code class="language-c">int processInlineBuffer(redisClient *c) {
    char *newline;
    int argc, j;
    sds *argv, aux;
    size_t querylen;

    // 获取当前命令行
    newline = strchr(c-&gt;querybuf, '\n');

    // 错误处理
    if (newline == NULL) {
        if (sdslen(c-&gt;querybuf) &gt; REDIS_INLINE_MAX_SIZE) {
            addReplyError(c, &quot;Protocol error: too big inline request&quot;);
            setProtocoError(c, 0);
        }
    }

    // 处理 \r\n 的情况，如果 \n 不是在 querybuf 的第一个字节且 \n 的前一个字节为 \r, 则 newline 回退一个字节
    if (newline &amp;&amp; newline != c-&gt;querybuf &amp;&amp; *(newline - 1) == '\r')
        newline--;

        // 得到命令的长度
        querylen = newline - (c-&gt;querybuf);
        // 得到确切的命令, 按空格或 &quot;&quot; 进行分割，比如
        // cmd &quot;hello world&quot; im sinsay
        // 可得到 [ cmd, &quot;hello world&quot;, im, sinsay ]
        aux = sdsnewlen(c-&gt;querybuf, querylen);
        argv = sdssplitargs(aux, &amp;argc);
        sdsfree(aux);
        if (argv == NULL) {
            addReplyError(c, &quot;Protocol error: unblanced quotes in request&quot;);
            setProtocolError(c, 0);
            return REDIS_ERR;
        }

        // 从 slave 发过来的空的 newline 表示要刷新 ack 信息
        if (querylen == 0 &amp;&amp; c-&gt;flags &amp; REDIS_SLAVE)
            c-&gt;repl_ack_time = server.unixtime;

        // 调整 querybuf, 使其跳过已获取到的 newline, 类似 substr 的操作
        sdsrange(c-&gt;querybuf, querylen + 2, -1);

        // 分配存放参数的内存块
        if (argc) {
            if (c-&gt;argc) zfree(c-&gt;argv);
            c-&gt;argv = zmalloc(sizeof(robj*) * argc);
        }

        // 这里创建的 argv 每个都是属于 robj 类型
        for (c-&gt;argc = 0, j = 0; j &lt; argc; j++) {
            if (sdslen(argv[j])) {
                c-&gt;argv[c-&gt;argc] = createObject(REDIS_STRING, argv[j]);
                c-&gt;argc++;
            }
            else {
                sdsfree(argv[j]);
            }
        }

        zfree(argv);
        return REDIS_OK;
}
</code></pre>
<p>上面唯一要重视的就是，<code>argv</code> 数组中的参数都是通过 <code>createObject</code> 创建的 <code>robj</code> 类型。<code>robj</code> 的结构在上篇的末尾已经介绍过，但我们还不了解各个字段的含义，现在我们看看到底是如何创建这个结构的。</p>
<pre><code class="language-c">robj *createObject(int type, void *ptr) {
    robj *o = zmalloc(sizeof(*o));
    o-&gt;type = type;
    o-&gt;encoding = REDIS_ENCODING_RAW;
    o-&gt;ptr = ptr;
    o-&gt;refcount = 1;
    o-&gt;lru = LRU_CLOCK();
    return o;
}
</code></pre>
<p>从上面的调用方式基本可以得到:</p>
<p>type 表示 obj 的类型，从定义我们可得到大致上有以下几种类型</p>
<pre><code class="language-c">#define REDIS_STRING 0
#define REDIS_LIST   1
#define REDIS_SET    2
#define REDIST_ZSET  3
#define REDIS_HASH   4
</code></pre>
<p>这不就是 redis 支持的数据结构么，OK。</p>
<p>encoding 这里看到的是 REDIS_ENCODING_RAW, 确定不了什么，再看看相关定义：</p>
<pre><code class="language-c">/* Objects encoding. Some kind of objects like String and Hashes can be
 * internally represented in multiple ways. The `encoding` field of the object
 * is set to one of this fields for this object */
#define REDIS_ENCODING_RAW        0   // Raw representation
#define REDIS_ENCODING_INT        1   // Encoded as integer
#define REDIS_ENCODING_HT         2   // Encoded as hash table
#define REDIS_ENCODING_ZIPMAP     3   // Encoded as zipmap
#define REDIS_ENCODING_LINKEDLIST 4   // Encoded as regular linked list
#define REDIS_ENCODING_ZIPLIST    5   // Encoded as ziplist
#define REDIS_ENCODING_INTSET     6   // Encoded as intset
#define REDIS_ENCODING_SKIPLIST   7   // Encoded as skiplist
#define REDIS_ENCODING_EMBSTR     8   // Embedded sds string encoding
</code></pre>
<p>再次可以确定，encoding 表示的是当前 obj 的具体实现，也就是这个 obj 可以是 REDIS_LIST 的类型，但他的具体实现可以使用 ZIPLIST 或 LINKEDLIST 之类的（~~我猜的~~）</p>
<p>而 ptr 就是具体实现的指针，具体能怎么使用这个 ptr, 取决于 type 跟 encoding.</p>
<p><code>refcount</code> 跟 <code>lru</code> 就基本可以从字面意思看出，一个是用来共享变量的，一个是用来 Least Recently Used 算法，可能是用来排除长时间不使用的 key 之类的。</p>
<p>到了这一步, 已经解析好了所有由客户端发出来的命令，并打包到 client 的 argc 跟 argv 字段 中，时刻准备着处理 :)</p>
<a class="header" href="redis/3. Redis 请求处理.html#a解析多个命令请求" id="a解析多个命令请求"><h3>解析多个命令请求</h3></a>
<p>另外一种情况是 reqtype 是 MULTIBULK 的时候，需要处理多个命令，我们看看实现做了什么。</p>
<pre><code class="language-c">int processMultibulkBuffer(redisClient *c) {
    chr *newline = NULL;
    int pos = 0, ok;
    long long ll;

    // 获取当前请求是由多少个命令组成的
    if (c-&gt;multibulklen == 0) {
        redisAssertWithInfo(c, NULL, c-&gt;argc == 0);

        newline = strchr(c-&gt;querybuf, '\r');
        if (newline == NULL) {
            // 异常处理
            return REDIS_ERR;
        }

        // querybuf 应该还包含 \n，所以 -2, 这是确认长度是正确的
        if (newline - (c-&gt;querybuf) &gt; ((signed)sdslen(c-&gt;querybuf) - 2)) {
            return REDIS_ERR;
        }

        redisAssertWithInfo(c, NULL, c-&gt;querybuf[0] == '*');
        ok = string2ll(c-&gt;querybuf + 1, newline - (c-&gt;querybuf + 1), &amp;ll);

        ...
    }
}
</code></pre>
<p>Ok, 在继续下去之前，我们从最后一句得到一个信息，也就是命令的格式：</p>
<pre><code class="language-json">    *NUMBER\r\n????
</code></pre>
<p>以 * 开头，以 \r\n 结尾的中间段，保存的是一个数字，用来表示之后的长度，具体是什么长度呢，继续分析。</p>
<pre><code class="language-c">        // ...
        // 长度不能超过 1024 * 1024
        if (!ok || ll &gt; 1024 * 1024) {
            // 异常处理
            return REDIS_ERR;
        }

        // pos 指向下一个命令的开始位置
        pos = (newline - c-&gt;querybuf) + 2;

        // 如果解析出来的命令数为0，则截断缓存后直接返回
        if (ll &lt;= 0) {
            sdsrange(c-&gt;querybuf, pos, -1);
            return REDIS_OK;
        }

        c-&gt;multibulklen = ll;

        // 分配内存用于存放命令参数
        if (c-&gt;argv) zfree(c-&gt;argv);
        c-&gt;argv = zmalloc(sizeof(robj *) * c-&gt;multibulklen);
    }

    redisAssertWithInfo(c, NULL, c-&gt;multibulklen &gt; 0);
    // 更具刚刚得到的命令数，逐个获取命令信息
    while (c-&gt;multibulklen) {
        // 获取当前命令的长度
        if (c-&gt;bulklen == -1) {
            newline = strchr(c-&gt;querybuf + pos, '\r');
            if (newline == NULL) {
                // 错误处理
                if (sdslen(c-&gt;querybuf) &gt; REDIS_INLINE_MAX_SIZE) {
                    return REDIS_ERR;
                }
                break;
            }

            // 如果 newline 位于 querybuf 的开头，则说明没东西可以处理了
            if (newline - (c-&gt;querybuf) &gt; ((signed)sdslen(c-&gt;queryuf) - 2)) {
                break;
            }

            // pos 现在当前命令的开始
            // 确认当前命令以 $ 开头
            if (c-&gt;querybuf[pos] != '$') {
                // 错误处理
                return REDIS_ERR;
            }

            ok = string2ll(c-&gt;querybuf + pos + 1, newline - (c-&gt;querybuf + pos + 1, &amp;ll);
            if (!ok || ll &lt; 0 || ll &gt; 512 * 1024 * 1024) {
                return REDIS_ERR;
            }

            // 获取到长度信息，更新 pos，指向下一个命令的位置
            pos += newline - (c-&gt;querybuf + pos) + 2;
            if (ll &gt;= REDIS_MBULK_BIG_ARG) {
                size_t qblen;

                // 如果现有的空间不够存放接下来的命令信息，则扩容 sds
                sdsrange(c-&gt;querybuf, pos, -1);
                pos = 0;
                qblen = sdslen(c-&gt;querybuf);
                if (qblen &lt; (size_t)ll + 2)
                    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, ll + 2 - qblen);
            }

            c-&gt;bulklen = ll;
        }
    }
</code></pre>
<p>再次暂停，从上面的分析我们基本得到了 BULK 模式下的消息结构</p>
<pre><code class="language-json">    *命令个数\r\n命令长度\r\n命令....
</code></pre>
<p>ok，可以继续了。</p>
<pre><code class="language-c">    // 如果 buffer 的长度不足以构成一个包，则跳出处理流程
    if (sdslen(c-&gt;querybuf) - pos &lt; (unsigned)(c-&gt;bulklen + 2)) {
        break;
    }
    else {
        // 如果已经处理到了最后
        if (pos == 0 &amp;&amp; c-&gt;bulklen &gt;= REDIS_MBULK_BIG_ARG &amp;&amp;
            (signed) sdslen(c-&gt;querybuf) == c-&gt;bulklen + 2) {
            c-&gt;argc[c-&gt;argc++] = createObject(REDIS_STRING, c-&gt;querybuf);
            sdsIncrLen(c-&gt;querybuf, -2);
            c-&gt;querybuf = sdsempty();
            c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,c-&gt;bulklen + 2);
            pos = 0;
        }
        else {
            c-&gt;argv[c-&gt;argc++] =
                createStringObject(c-&gt;querybuf + pos, c-&gt;bulklen);
            pos += c-&gt;bulklen + 2;
        }
        c-&gt;bulklen = -1;
        c-&gt;multibulklen--;
    }

    if (pos) sdsrange(c-&gt;querybuf, pos, -1);
    if (c-&gt;multibulklen == 0) return REDIS_OK;

    return REDIS_ERR;
</code></pre>
<p>跟单行的请求一样，只是这里会同时处理多个请求，接下来我们可以真正的进入处理请求的流程了。</p>
<a class="header" href="redis/3. Redis 请求处理.html#a处理请求" id="a处理请求"><h2>处理请求</h2></a>
<p>上面的处理已经把所有的请求信息，都放进了当前 client 的 argc 跟 argv 中，接下来只需要遍历 argv 即可获取对应的参数跟数据进行处理了。</p>
<pre><code class="language-c">int processCommand(redisClient *c) {
    // 如果客户端发过来的是 quit 命令，则直接回复退出成功，并把客户端标示为 REDIS_CLOSE_AFTER_REPLY
    if (!strcasecmp(c-&gt;argv[0]-&gt;ptr, &quot;quit&quot;)) {
        addReply(c, shared.ok);
        c-&gt;flags |= REDIS_CLOSE_AFTER_REPLY;
    }
}
</code></pre>
<p>这时候我们可以确定刚刚处理命令时遇到的对 REDIS_CLOSE_AFTER_REPLY 的处理了，也就是说，如果客户已明确标示要断开连接了，那接下来所有的操作我们都可以直接忽略。 OK 继续。</p>
<pre><code class="language-c">    // 根据用户发送的命令，获取具体的 cmd
    c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[0]-&gt;ptr);
    // 然后是一系列的错误检查，如果没有找到对应的命令，则说明命令格式错误
    // 然后如果参数的数量不一致的话，也视为出错
    if (!c-&gt;cmd) {
        flagTransction(c);
        addReplyErrorFormat(c, &quot;unknown command '%s'&quot;,
            (char *)c-&gt;argv[0]-&gt;ptr);
        return REDIS_OK;
    }
    else if ((c-&gt;cmd-&gt;arity &gt; 0 &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||
                (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) {
        flagTransaction(c);
        addReplyErrorFormat(c, &quot;wrong number of arguments for '%s' command&quot;,
            c-&gt;cmd-&gt;name);
        return REDIS_OK;
    }
</code></pre>
<p>接下来就是具体处理命令了，在开始处理之前我们先看看 redisCommand 的具体定义</p>
<pre><code class="language-c">struct redisCommand {
    // 命令名
    char *name;
    // 命令的函数指针
    redisCommandProc *proc;
    // 命令的参数数
    int arity;
    // 命令的标志，字符串表示形式，每个字符一个标示
    char *sflags;
    // 命令的标志，位模式，由 sflags 决定
    int flags;
    // 用于 Cluster 的转发，暂时不管
    redisGetKeysProc *getkeys_proc;
    // 以下几个不明，待分析
    int firstkey;
    int lastkey;
    int keystep;
    long long microseconds, calls;
}

typedef void redisCommandProc(redisClient *c);
</code></pre>
<p>然后继续处理命令</p>
<pre><code class="language-c">    // 检查服务是否需要验证，如果需要验证，则检查是否已通过验证，因为还没通过验证的客户端，只接受验证命令 authCommand
    if (server.requirepass &amp;&amp; !c-&gt;authenticated &amp;&amp; c-&gt;cmd-&gt;proc != authCommand) {
        flagTranscation(c);
        addReply(c, shared.noautherr);
        return REDIS_OK;
    }

     // 如果处于 Cluster 模式，则只处理以下两种情况
     //     1. 命令是从 Master 发过来的
     //     2. 命令没有参数
     if (server.cluster_enabled &amp;&amp;
         !(c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;
         !(c-&gt;flags &amp; REDIS_LUA_CLIENT &amp;&amp;
           server.lua_caller-&gt;flags &amp; REDIS_MASTER) &amp;&amp;
         !(c-&gt;cmd-&gt;getkeys_proc == NULL &amp;&amp; c-&gt;cmd-&gt;firstkey = 0)) {
        int hashslot;

        // 如果当前的 Cluster 模式是正常的，执行 Redirect 操作，
        // 否则处理错误
        if (server.cluster-&gt;state != REDIS_CLUSTER_OK) {
            flagTranscation(c);
            clusterRedirectClient(c, NULL, REDIS_CLUSTER_REDIR_DOWN_STATE);
            return REDIS_OK;
        }
        else {
            int error_code;
            clusterNode *n = getNodeByQuery(c, c-&gt;cmd, c-&gt;argc,  &amp;hashslot, &amp;error_code);
            if (n == NULL || n != server.cluster-&gt;myself) {
                flagTranscation(c);
                clusterRedirectClient(c, n, hashslot, error_node);
                return REDIS_OK;
            }
        }
     }

     // 如果设置了内存限制，则检查内存使用状况
     if (server.maxmemory) {
        // 这里开始执行内存回收策略，遍历所有的 DB，根据 DB 配置的策略选择对应的 key 进行回收
        int retval = freeMemoryIfNeeded();
        if ((c-&gt;cmd-&gt;flags &amp; REDIS_CMD_DENYOOM) &amp;&amp; retval == REDIS_ERR) {
            flagTranscation(c);
            addReply(c, shared.oomerr);
            return REDIS_OK;
        }
     }

     // 当 bgsave 或者 aof 机制出错时，拒绝执行 &quot;Write&quot; 操作，也就是拒绝执行任何会导致数据写入磁盘的操作（包括 PING)
     if (((server.stop_writes_on_bgsave_err &amp;&amp;
           server.saveparamslen &gt; 0 &amp;&amp;
           server.lastbgsave_status == REDIS_ERR) ||
           server.aof_last_write_status == REDIS_ERR) &amp;&amp;
         server.masterhost == NULL &amp;&amp;
         (c-&gt;cmd-&gt;flags &amp; REDIS_CMS_WRIETE ||
          c-&gt;cmd-&gt;proc == pingCommand)) {

          flagTranscation(c);
          if (server.aof_last_write_status == REIDS_OK)
            addReply(c, shared.bgsaveerr);
          else
            addReplySds(c,
                sdscatprintf(sdsempty(),
                &quot;-MISCONF Errors writeing to the AOF fiel: %s\r\n&quot;,
                strerror(server.aof_last_write_errno)));
          return REDIS_OK;
      }

      // 如果设置了 min_slaves_to_write 最小从机数并且现在可用的从机少于这个数字，则拒绝 Write 操作
      if (server.masterhost == NULL &amp;&amp;
          server.repl_min_slaves_to_write &amp;&amp;
          server.repl_min_slaves_max_log &amp;&amp;
          c-&gt;cmd-&gt;flags &amp; REDIS_CMD_WRITE &amp;&amp;
          server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write) {
          flagTranscation(c);
          addReply(c, shared.noreplicaserr);
          return REDIS_OK;
      }

      // 如果是从机，并且是只读的从机，则拒绝执行 Write 操作
      if (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;
          !(c-&gt;flags &amp; REDIS_MASTER) &amp;&amp;
          c-&gt;cmd-&gt;flags &amp; REDIS_CMD_WRITE) {
          addReply(c, shared.roslaveerr);
          return REDIS_OK;
      }

      // 如果当前客户端是 PUBSUB 模式，则只接受跟 pubsub 相关的操作
      if (c-&gt;flags &amp; REDIS_PUBSUB &amp;&amp;
          c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;
          c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;
          c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;
          c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;
          c-&gt;cmd-&gt;proc != punsubscribeCommand) {
          addReplyError(c, &quot;only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context&quot;);
          return REDIS_OK;
      }

      // 如果从机的状态未跟主机同步，则只接受 INFO 跟 SLAVEOF 操作
      if (server.masterhost &amp;&amp; server.repl_state != REDIS_REPL_CONNECTED &amp;&amp;
          server.repl_server_state_data == 0 &amp;&amp;
          !(c-&gt;cmd-&gt;flags &amp; REDIS_CMD_STALE)) {
          flagTranscation(c);
          addReply(c, shared.masterdownerr);
          return REDIS_OK;
      }

      // 如果 Redis 服务仍在初始化阶段，则回复对应的信息给客户端
      if (server.loading &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; REDIS_CMD_LOADING)) {
        addReply(c, shared.loadingerr);
        return REDIS_OK;
      }

      // 如果执行的 lua 脚本太慢了，则限制只能执行有限的操作
      if (server.lua_timeout &amp;&amp;
          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;
          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;
          !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;
            c-&gt;argc == 2 &amp;&amp;
            tolower(((char *)c-&gt;argv[1]-&gt;prt)[0] == 'n') &amp;&amp;
          !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;
            c-&gt;argc == 2 &amp;&amp;
            tolower(((char *)c-&gt;argv[1]-&gt;ptr)[0] == 'k')) {

            flagTranscation(c);
            addReply(c, shared.slowscripterr);
            return REDIS_OK;
        }

        // 正式执行命令。。。
        // 不容易啊。。。。。
        // 如果当前处于多命令 MULTI 状态，则如果不是要求执行或取消已经放入队列的命令的话，将新命令加入执行队列
        if (c-&gt;flags &amp; REDIS_MULTI &amp;&amp;
            c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;
            c-&gt;cmp-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand) {
            queueMultiCommand(c);
            addReply(c, shared.queued);
        }
        else {
            call(c, REDIS_CALL_FULL);
            c-&gt;woff = server.master_repl_offset;
            if (listLength(server.ready_keys))
                handleClientBlockedOnLists();
        }

        return REDIS_OK;
}
</code></pre>
<p>到了这里，终于把接收请求跟对请求跟命令进行分析部分写完了，最后我们再来看看，执行 <code>Multi</code> 模式的命令是怎么加入队列的。</p>
<pre><code class="language-c">void queueMultiCommand(redisClient *c) {
    multiCmd *mc;
    int j;
    c-&gt;mstat.commands = zrealloc(c-&gt;mstate.commands,
        sizeof(multiCmd) * (c-&gt;mstate.count + 1));
    mc = c-&gt;mstate.commands + c-&gt;mstate.count;
    mc-&gt;cmd = c-&gt;cmd;
    mc-&gt;argc = c-&gt;argc;
    mc-&gt;argv = zmalloc(sizeof(robj *) * c-&gt;argc;
    memcpy(mc-&gt;argv, c-&gt;argv, sizeof(robj *) * c-&gt;argc);
    for (j = 0; j &lt; c-&gt;argc; j++)
        increRefCount(mc-&gt;argv[j]);
    c-&gt;mstate.count++;
}
</code></pre>
<p>这里可以看到，client 会维护一个 mstate 来保存当前命令的列表，在有新的命令进来时，将其加入命令列表，并增加对应对象的引用信息。引用信息是 robj 用来共享变量所使用的。</p>
<p>最后剩下的，就是命令具体的执行方式了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="redis/2. Redis 分析起步.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="redis/4. Redis 执行命令.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="redis/2. Redis 分析起步.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="redis/4. Redis 执行命令.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
