<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>skiplist - SinSay's Note Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="about.html"><strong aria-hidden="true">1.</strong> About Me</a></li><li><a href="tokio.html"><strong aria-hidden="true">2.</strong> Tokio Tutirial (译)</a></li><li><ol class="section"><li><a href="tokio/tutorial-hello.html"><strong aria-hidden="true">2.1.</strong> Hello</a></li><li><a href="tokio/tutorial-spawning.html"><strong aria-hidden="true">2.2.</strong> Spawning</a></li><li><a href="tokio/tutorial-shared state.html"><strong aria-hidden="true">2.3.</strong> Shared State</a></li><li><a href="tokio/tutorial-channel.html"><strong aria-hidden="true">2.4.</strong> Channel</a></li><li><a href="tokio/tutorial-io.html"><strong aria-hidden="true">2.5.</strong> I/O</a></li><li><a href="tokio/tutorial-framing.html"><strong aria-hidden="true">2.6.</strong> Framing</a></li><li><a href="tokio/tutorial-indepth.html"><strong aria-hidden="true">2.7.</strong> Async In Depth</a></li><li><a href="tokio/tutorial-select.html"><strong aria-hidden="true">2.8.</strong> Select</a></li><li><a href="tokio/tutorial-streams.html"><strong aria-hidden="true">2.9.</strong> Streams</a></li></ol></li><li><a href="https://sinsay.github.io/db/index.html"><strong aria-hidden="true">3.</strong> Database Internals</a></li><li><a href="data_struct.html"><strong aria-hidden="true">4.</strong> DataStruct</a></li><li><ol class="section"><li><a href="redis/sds.html"><strong aria-hidden="true">4.1.</strong> sds</a></li><li><a href="redis/dict.html"><strong aria-hidden="true">4.2.</strong> dict</a></li><li><a href="redis/skiplist.html" class="active"><strong aria-hidden="true">4.3.</strong> skiplist</a></li><li><a href="redis/intset.html"><strong aria-hidden="true">4.4.</strong> intset</a></li><li><a href="redis/ziplist.html"><strong aria-hidden="true">4.5.</strong> ziplist</a></li></ol></li><li><a href="redis.html"><strong aria-hidden="true">5.</strong> Redis</a></li><li><ol class="section"><li><a href="redis/1.redis-basic.html"><strong aria-hidden="true">5.1.</strong> 基本定义</a></li><li><a href="redis/2.redis-analyse.html"><strong aria-hidden="true">5.2.</strong> 分析起步</a></li><li><a href="redis/3.redis-process.html"><strong aria-hidden="true">5.3.</strong> 请求处理</a></li><li><a href="redis/4.redis-execute.html"><strong aria-hidden="true">5.4.</strong> 执行命令</a></li></ol></li><li><a href="distributed.html"><strong aria-hidden="true">6.</strong> Distributed</a></li><li><ol class="section"><li><a href="distributed/mapreduce_note.html"><strong aria-hidden="true">6.1.</strong> MapReduce (译)</a></li><li><a href="distributed/raft_note.html"><strong aria-hidden="true">6.2.</strong> Raft (译)</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">SinSay's Note Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="redis/skiplist.html#a跳跃表" id="a跳跃表"><h1>跳跃表</h1></a>
<p>[TOC]</p>
<a class="header" href="redis/skiplist.html#a介绍" id="a介绍"><h2>介绍</h2></a>
<p>跳跃表是一种有序的列表，可以提供平均 O(logN)、最差 O(N) 复杂度的查找性能，而且相对于 AVL 跟 RB Tree 之类的结构来说有两大优势：</p>
<ul>
<li>实现简单很多</li>
<li>平均性能差不多</li>
</ul>
<p>所以有不少的实现在实现有序的 Set 时，更倾向于使用跳跃表，而且跳跃表在搜索引擎的实现中也占很重要的一部分。</p>
<p>在这里我们选择使用 <strong>redis 的跳跃表</strong>实现来对其进行分析。
首先我们介绍一下他的大致结构</p>
<p><img src="./image/skiplist_linklist_complete.png" alt="" /></p>
<p>如图所示，所谓的跳跃表，即是在有序的列表中，加入了跳跃使用的指针，以允许从当前节点直接访问后续的其他节点，而不是只能通过遍历的形式来访问其他节点。
接着我们再看看他的基本定义：</p>
<pre><code class="language-c">// 跳跃表的节点定义
typedef struct zskiplistNode {
    void *obj;  // 当前节点的值
    double score; // 当前节点的分值
    struct zskiplistNode *backward; // 指向上一个节点
    struct zskiplistLevel {
        struct zskiplistNode *forward;  // 下一层节点
        unsigned int span;  // 跃度，也就是跳跃的距离
    } level []; 
} zskiplistNode;

// 跳跃表的定义
typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;
</code></pre>
<p>整个跳跃表由 zskiplistNode 跟 zskiplist 组成；
zskiplist 负责管理整个链表的情况，如使用 header 跟 tail 来提供正反两个方向的遍历。
使用 length 来保存列表中 item 的数目，并使用 level 来提示算法，当前跳跃表的最高层数
<strong><em>需要注意的是，header 永远是有 MAX 层的，所以 header 的层数不计入 level 中。</em></strong></p>
<a class="header" href="redis/skiplist.html#a实现" id="a实现"><h2>实现</h2></a>
<a class="header" href="redis/skiplist.html#a创建-skiplist" id="a创建-skiplist"><h3>创建 skiplist</h3></a>
<p>接着是 zskiplistNode 的介绍</p>
<ul>
<li>obj 是保存对象的指针</li>
<li>score 是当前对象的分值，也就是用于排序的依据，这个一般会由内部算法生成，一般是为了提供区间搜索，比如得到某个分值区间的数据。</li>
<li><strong>综合以上两点，排序有两种方式，一种是依据 obj 本身的比较函数，另一种是依据 score</strong></li>
</ul>
<p><strong>所以在下面的例子中，避免复杂度，所有的测试都以 score 为准</strong></p>
<p>接下来我们从代码层面开始分析，首先是 skiplist 的初始化</p>
<pre><code class="language-c">zskiplistNode *zslCreateNode(int level, double score, void *obj) {
    zskiplistNode *zn = zmalloc(
        sizeof(*zn) * level * sizeof(struct zskiplistLevel));
    zn-&gt;score = score;
    zn-&gt;obj = obj;
    return zn;
}
zskiplist *zslCreate(void) {
    int j;
    zskiplist *zsl;
    
    // 对于 zmalloc 可以理解为就是 malloc 的简单封装，以便于随时更改内存分配器
    zsl = zmalloc(sizeof(*zsl));
    zsl-&gt;level = 1;
    zsl-&gt;length = 0;
    
    // 这里即是分配出一个有 ZSKIPLIST_MAXLEVEL 层的节点作为 header
    // 并把新建节点的 score 设为 0，obj 设为 NULL
    // 正如上面所说的，header 本身是不列入层数计算，并且不存放任何 obj 的
    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL, 0, NULL);
    for (j = 0; j &lt; ZSKIPLIST_MAXLEVEL; j++) {
        zsl-&gt;header-&gt;level[j].forward = NULL;
        zsl-&gt;header-&gt;level[j].span = 0;
    }
    zsl-&gt;header-&gt;backward = NULL;
    zsl-&gt;tail = NULL;
    return zsl;
}
</code></pre>
<p>通过以上函数，调用 zslCreate 之后，即可得到一个初始化完成的 skiplist，结构大致如下</p>
<div id="init_state"></div>
<pre><code class="language-sh">                                           _____
[ level  ] = 1                            | MAX | --&gt; NULL
[ length ] = 0                            |  .  | --&gt; NULL
[ header ] -------&gt;  [ score ] = 0        |  .  | --&gt; NULL
[  tail  ] = NULL    [ obj   ] = NULL     |  .  | --&gt; NULL
                     [ level ] ---------&gt; |  1  | --&gt; NULL
                                          |  0  | --&gt; NULL
                                          |_____|
</code></pre>
<a class="header" href="redis/skiplist.html#a插入数据" id="a插入数据"><h3>插入数据</h3></a>
<p>接下来我们通过测试代码来逐步分析 skiplist 在进行操作时会有什么动作</p>
<div id="testcode"></div>
<pre><code class="language-c">
// 初始化要插入的对象
int array[10];
for (int i = 0; i &lt; (sizeof(array) / sizeof(int)); i++) {
    array[i] = i + 1;
}

zskiplist *sl = zslCreate();
zskiplistNode *node = zslInsert(sl, array[0], array);
zskiplistNode *node2 = zslInsert(sl, array[1], array + 1);

</code></pre>
<p>上面的代码我们初始化了一个包含 10 个数字的数字，作为 obj 来插入列表
然后测试插入了两个元素，包括第一个 score 为 1 obj 为 1 的对象，以及第二个 score 为 2 obj 为 2 的对象。
接下来我们先分析下， <code>zslInsert</code> 到底做了什么。</p>
<pre><code class="language-c">zskiplistNode *zslInsert(zskiplist *zsl, double score, void *obj) {
    // x 是当前处理的节点
    // update 数组保存的是:
    // 小于 新节点的节点将指向新节点，大于新节点的节点将更新 span
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned int rank[ZSKIPLIST_MAXLEVEL];
    int i, level;
    
    x = zsl-&gt;header; // 首先获取 header
    // 从当前 skiplist 的最高层开始查找合适的位置，因为越高层指向的目标就可能越远
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        // storea rank that is crossed to reach the insert position
        // 保存 rank ???
        rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];
        
        // 如果新增对象的 score 小于下一个节点的 score
        // 或 score 相等但 compare 的结果小于下一节点的 obj
        // 这里使用下一节点是因为，当前节点是从 header 开始的，而 header 是存实际 obj 的
        while (x-&gt;level[i].forward &amp;&amp;
            (x-&gt;level[i].forward-&gt;score &lt; score ||
                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; 0)
            )) {
             
             // rank 加上当前节点当前层的跨度？
             rank[i] += x-&gt;level[i].span;
             x = x-&gt;level[i].forward;
         }
         // 保存所有节点到 update 中
         update[i] = x;
    }
    
    // 新建一个节点，给予一个随机的层级
    level = zslRandomLevel();
    // 如果新节点的层数大于现有的最大层，则更新现有的所有旧有层次
    if (level &gt; zsl-&gt;level) {
        for (i = zsl-&gt;level; i &lt; level; i++) {
            // 更新所有旧有层次，让其指向 header,
            // 并让所有第 i 层的 span 跨度设为 zsl 的节点数，也就是直接跨越到最后
            rank[i] = 0;
            update[i] = zsl-&gt;header;
            update[i]-&gt;level[i].span = zsl-&gt;length;
        }
        zsl-&gt;level = level; // 更新 skiplist 的最高层为
    }
    
    // 终于到创建新节点的这步了，创建一个 level 层的节点，并设置好 sroce 跟 obj
    x = zslCreateNode(level, score, obj); 
    
    // 更新新节点的低于旧有最高层的层次
    for (i = 0; i &lt; level; i++) {
        // 更新 x 的第 i 层节点的指向
        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
        update[i]-&gt;level[i].forward = x;
        
        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
        update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
    }
    
    // 将所有高于新节点的层的跨度增加 1
    for (i = level; i &lt; zsl-&gt;level; i++) {
        update[i]-&gt;level[i].span++;
    }
    
    // 更新新节点的后退指针，如果是第一层，则设置为 NULL(因为没有上一层了）
    // 否则设置为 update[0] ??
    x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
    // 如果有下一个节点，则将下一个节点的后退指针设为新节点
    if (x-&gt;level[0].forward)
        x-&gt;level[0].forward-&gt;backward = x;
    else
        // 如果没有下一个节点，说明是最后一个节点
        zsl-&gt;tail = x; 
        
    zsl-&gt;length++;
    return x;
}
</code></pre>
<p>redis 的 skiplist 的插入代码较长，所以我们分段进行分析，并且在分析的时候已我们的测试代码为准，如我们现在即将调用的</p>
<pre><code class="language-c">// array[0] = 1
// array    = 1 
zskiplistNode *node = zslInsert(sl, array[0], array);
</code></pre>
<p>首先从 <a href="redis/skiplist.html#init_state">初始化图</a> 可以得知 skiplist 现在的状态，接下来逐步分析插入的代码，
我们向 sl 插入了 score 为 1，obj 指向 1 的信息，接下来进入函数的第一步骤</p>
<pre><code class="language-c">x = zsl-&gt;header;
// 当前的 level 是 1, 所以只会循环一次，并且 i = 0
for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
    // 所以这里的 rank[i] = 0;
    rank[i] = i == (zsl-&gt;level-1) ? 0 : rank[i+1];    
    
    // 而这里的 forward 一开始是为 NULL 的，所以不会进入循环
    while (x-&gt;level[i].forward &amp;&amp;
        (x-&gt;level[i].forward-&gt;score &lt; score ||
            (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
            compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; 0)
        )) {
         
         rank[i] += x-&gt;level[i].span;
         x = x-&gt;level[i].forward;
     }
     
     update[i] = x;
}
</code></pre>
<p>所以执行完之后，各变量的状态转为</p>
<pre><code class="language-c">x      = header;
update = [ header, NULL, ... ];
rank   = [ 0, 0, 0, ... ];
</code></pre>
<p>并假设新节点的层级由随机数得到 3，则下面的第二步骤的具体细节为</p>
<pre><code class="language-c">level = zslRandomLevel(); // 假设为 3
// 当前 zsl-&gt;level 为 1， 所以进入循环
if (level &gt; zsl-&gt;level) {
    // 这边的循环则是更新指定的 update 跟 rank
    for (i = zsl-&gt;level; i &lt; level; i++) {
        // 更新所有旧有层次，让其指向 header,
        // 并让所有第 i 层的 span 跨度设为 zsl 的节点数，也就是直接跨越到最后
        rank[i] = 0;
        update[i] = zsl-&gt;header;
        update[i]-&gt;level[i].span = zsl-&gt;length;
    }
    zsl-&gt;level = level; // 更新 skiplist 的最高层为
}
</code></pre>
<p>执行完后，各变量的状态转为</p>
<pre><code class="language-c">zsl-&gt;level = 3;
update = [ header, header, header, NULL, ... ];
rank   = [0, 0, 0, ... ];
header-&gt;level[1].span = 1;
header-&gt;level[2].span = 1;
</code></pre>
<p>接下来是插入的最后一个步骤了，这里会依据 update 的内容来更新 skiplist，并且会往其中加入新节点</p>
<pre><code class="language-c">// 创建新节点
x = zslCreateNode(level, score, obj); 
    
for (i = 0; i &lt; level; i++) {
    // 将新节点的各层的 forward 设置为对应 update 的 forward
    // 并将原有 update 节点的 forward 指向新节点
    x-&gt;level[i].forward = update[i]-&gt;level[i].forward;
    update[i]-&gt;level[i].forward = x;
    
    // 将新节点各层的 span 设置为原有节点对应层的 span 并减去 rank[0] - rank[i];
    x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);
    // 然后更新原有 update 对应层的 span 为 rank[0] - rank[i] + 1，也就是对应的 span 加上1 
    update[i]-&gt;level[i].span = (rank[0] - rank[i]) + 1;
}
    
// 将所有高于新节点的层的跨度增加 1
for (i = level; i &lt; zsl-&gt;level; i++) {
    update[i]-&gt;level[i].span++;
}
    
// 更新新节点的后退指针，如果是第一层，则设置为 NULL(因为没有上一层了）
// 否则设置为 update[0] ??
x-&gt;backward = (update[0] == zsl-&gt;header) ? NULL : update[0];
// 如果有下一个节点，则将下一个节点的后退指针设为新节点
if (x-&gt;level[0].forward)
    x-&gt;level[0].forward-&gt;backward = x;
else
    // 如果没有下一个节点，说明是最后一个节点
    zsl-&gt;tail = x; 
    
zsl-&gt;length++;
return x;
</code></pre>
<p>这次调用马上结束了，最后来看看这次的调用结果，将 zsl 这个 skiplist 变成什么样了，</p>
<pre><code class="language-json">x = {
    backward: NULL,
    score   : 3,
    obj     : 3,
    level   : [ NULL, ... ]
}

zsl = {
    leve  : 3
    length: 1
    header: -----&gt;  [ score ] = 0
    tail  : x       [ obj   ] = NULL
                    [ level ] = [ ... ]       
}                                                                   
                           
zsl-&gt;header.level = [                        
    {                            ____            
        span: 1, forward ----&gt;  |    |
    },                          |  x |
    {                           |  3 |
        span: 1, forward ----&gt;  |  3 |
    },                          |    |
    {                           |    |
        span: 1, forward ----&gt;  |____|
    }
]
</code></pre>
<p>接下来分析第二次插入时的情况，这次我们就不逐步分析，而是直接查看插入后的结果了。
首先是对第一步骤的分析，我们现在要插入的节点是 score = 3, obj = 3，在执行完第一步骤后继续执行第二步骤，根据新节点的随机 level 填充 update 跟更新 skiplist 的 level, 我们假设新节点的随机层数为 2 ，则执行代码</p>
<pre><code class="language-c">zslInsert(zsl, array[2], array + 2); // 3, 3
</code></pre>
<!--
x = header;
zsl->level = 3;
rank = [ 0, 0, 0, ... ]
<p>第一次循环 i == 2</p>
<p>rank[2] = 0;
rank[2] = x-&gt;level[2].span = 1
x = x-&gt;level[2].forward = { score: 1, obj: 1, level: [ NULL, ... ] }
rank = [0, 0, 1, ...]
update = [ NULL, NULL, { 1, 1 }, ...]</p>
<p>第二次循环 i == 1
rank[1] = rank[2] = 1
update[1] = x = { 1, 1 }
rank = [0, 1, 1]
update = [ NULL, { 1, 1 }, { 1, 1}, ... ]</p>
<p>第三次循环 i == 0
rank[0] = rank[1] = 1
update[i] = { 1, 1 }
rank = [ 1, 1, 1 ]
update = [ { 1, 1 }, { 1, 1 }, { 1, 1 } ]</p>
<p>level = 2, 因为 level &lt; zsl-&gt;level 所以没进入循环
--&gt;</p>
<pre><code class="language-json">x = {                       zsl = {
    backward: NULL,             level: 3,
    score: 3,                   length: 1,
    obj  : 3,                   header: ------&gt; header,
    level: [ empty, ... ]    };
};                           

level = 2
rank = [ 1, 1, 1, ... ]
// update 列表中对象是指 { level, score, obj }
update = [ { 3, 3, 3 }, { 3, 3, 3 }, { 3, 3, 3 }, ... ]
</code></pre>
<p>第三步骤，则负责更新整个 update 对应的对象，以及新对象的指针</p>
<!--
for 0 -> 2
第一次循环 i = 0
x->level[0].forward = update[0]->level[0].forward; = NULL
update[0]->level[0].forward = x
x->level[0].span = update[0].level[0].span = 0 - (rank[0] - rank[0]) = 0
update[0].level[i].span = (rank[0] - rank[0] + 1 = 1
<p>总共三步循环都是把旧有节点指向 x，并更新对应的指针跟 rank</p>
<p>x-&gt;backward = (update[0]) = { 1, ,1 1 }
zsl-&gt;tail = x
zsl-&gt;length++;
--&gt;
<img src="./image/skiplist_status1.jpg" alt="状态1" /></p>
<p>下面我们继续插入新的数据节点，这次插入的是另一个节点</p>
<pre><code class="language-c">zslInsert(zsl, array[1], array + 1); // 2, 2
</code></pre>
<p>并且我们假设其随机生成的层数 level 为 4 层，则插入之后 skiplist 的状态为</p>
<!--
x = header;
循环3次
i == 2
rank[2] = 0;
rank[2] = 1
x = { 1, 1, 1 }
update[2] = { 1, 1, 1 }
<p>i == 1
rank[1] = 1
x = { 1, 1, 1 }
update[1] = { 1, 1, 1 }</p>
<p>i == 0
rank[i] = 1
x = { 1, 1, 1 }
update[0] = { 1, 1, 1 }</p>
<p>level = 4
for ( i = 3 ; i &lt; 4; i++) {
update...
}
rank[3] = 0;
update[3] = header
update[3]-&gt;level[3].span = 2</p>
<p>rank = [1, 1, 1, 0, ...]
update = [ {1,1,1}, {1,1,1}, {1,1,1}, {0,0,0} ]
zsl-&gt;level = 4</p>
<p>x = { 4, 2, 2 } // level 4, score 2, obj 2
for(i = 0; i &lt; 4; i++) {
}
x-&gt;level[0].forward = update[0]-&gt;level[0].forward;
x-&gt;level[0].forward = {1,1,1}[0].forward; = {3,3,3}</p>
<p>x-&gt;level[0].span = update[0]-&gt;level[0].span - (rank[0] - rank[0])
= {1,1,1}[0].span - 0 = 0</p>
<p>x-&gt;level[1].forward = update[1]-&gt;level[1].forward
x-&gt;level[1].forward = {1,1,1}[1].forward;
x-&gt;level[1].span = update[1]-&gt;level[1].span - (rank[0] - rank[1])
= {1,1,1}[1].span - (1-1) = 0</p>
<p>x-&gt;level[2].forward = update[2]-&gt;level[2].forward;
x-&gt;level[2].forward = {1,1,1}[2].forward;
x-&gt;level[2].span = update[2]-&gt;level[2].span - (rank[0] - rank[2])
= {1,1,1}[2].span - (1-1) = 0</p>
<p>x-&gt;level[3].forward = update[3]-&gt;level[3].forward
= header[3].forward = NULL<br />
x-&gt;level[3].span = header[3].span - (0 - rank[3]) = 1</p>
<p>--&gt;</p>
<p><img src="./image/skiplist_status2.jpg" alt="" /></p>
<a class="header" href="redis/skiplist.html#a查找数据" id="a查找数据"><h3>查找数据</h3></a>
<p>插入一定量的数据之后，整个 skiplist 树已经趋于稳定状态，现在我们开始来介绍下查找数据的流程，同样的，我们还是以测试代码为驱动，来分析具体的查找流程，一下是测试代码</p>
<pre><code class="language-c">// 函数原型
zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);

// 测试代码
zskiplistNode *node;
node = zslGetElementByRank(zsl, 2); // 获取排名第二的元素
</code></pre>
<p>因为整个 skiplist 都是有序的，所以最简单的查找方式就是从头开始找（<em>当然也可以从后面开始找，这样就可以换一种顺序来得到数据了，但我们为了简单只讨论第一种</em>），但因为 skiplist 为我们提供了指向多级节点之后的指针，我们才能提高查找的效率。
从上面的结构图我们可以看到，从层数来分析，层级越高的元素，能够跨越的距离就越远，所以在进行搜索的时候我们会倾向于从最高点开始往下找，这样就能充分利用 skiplist 为我们提供的效率。
接下来继续看看 skiplist 的查找实现</p>
<pre><code class="language-c">zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
    zskiplistNode *x;
    unsigned long traversed = 0;
    int i;
    
    x = zsl-&gt;header;
    // 从当前最高层开始，遍历所有的层
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        // 如果当前节点的当前层跟下一节点的距离，小于我们想查找的位置，
        // 则将当前节点指向下一节点，并将已经跨越的距离加上当前节点跟下一节点的距离
        while (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span &lt;= rank)) {
            traversed += x-&gt;level[i].span;
            x = x-&gt;level[i].forward;
        }
        
        // 如果找到了对应的层级
        if (traversed == rank) {
            return x;
        }
    }
    return NULL;
}
</code></pre>
<p>具体的实现也是跟设定的逻辑一致，从最高层开始最小化查找的次数。</p>
<a class="header" href="redis/skiplist.html#a查找的另一种方式" id="a查找的另一种方式"><h4>查找的另一种方式</h4></a>
<p>接下来看另外一个实现，查找某个元素，因为保存的是 <code>void*</code> 指针，所以就导致了，必须提供自定义的比较函数，否则就会使用直接比较指针地址的方式。</p>
<pre><code class="language-c">// 函数原型
typedef int (cmpfunc)(void *x, void *y);
zskiplistNode* zslGetNode(zskiplist *zsl, void *obj, cmpfunc cmp);

int cmp(void *xp, void *yp) {
    int x = *(int *)xp;
    int y = *(int *)yp;
    
    if (x == y) { 
        return 0;
    }
    else if (x &lt; y) {
        return -1;
    }
    else {
        return 1;
    }
}

// 开始查找
int i = 3;
zskiplistNode *node = zslGetNode(zsl, &amp;i, cmp);

</code></pre>
<p>为了便于理解，我们首先把查找的过程以图形的方式画出。</p>
<p><img src="./image/skiplist_status3.jpg" alt="" /></p>
<p>查找方式跟之前的还是相同的，区别就只是不再按 score 查找，而是根据 obj 之间的 cmp 函数，来决定是要使用当前层往前找，还是使用第一层的指针往前找而已。下面是具体的查找代码</p>
<pre><code class="language-c">zskiplistNode* zslGetNode(zskiplist *zsl, void *obj, cmpfunc cmp) {
    zskiplistNode *x;
    int c;
    int i;
    
    x = zsl-&gt;header;
    for (i = zsl-&gt;level; i &gt;= 0; i--) {
    
        while ( (c = cmp(obj, x-&gt;level[i].forward-&gt;obj)) &lt; 0) {
            x = x-&gt;level[i].forward;
        }
        
        if (c == 0) { // found it!
            return x-&gt;level[i].forward;	
        }
    }
    
    return NULL;
}
</code></pre>
<a class="header" href="redis/skiplist.html#a删除" id="a删除"><h3>删除</h3></a>
<p>看完上面的所有介绍后，其实可以很容易的就联想到，关于 skiplist 的操作，基本都是基于其中的 update 指针，也就是那个指向指定节点 x 的前置节点集合。只要得到这个集合，要删除某个操作时，只需要将 update 指针指向 x 的节点，改成指向 x 对应层级的下一层就可以了，而高度高于 x 节点的，则只需要将 span 减少。
<em>redis 的源码中给出的是针对某个 score 的 robj 的比较</em></p>
<pre><code class="language-c">int zslDelete(zskiplist *zsl, double score, robj *obj) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;
    
    // 首先更新 update 为指向对应 score 跟 obj 节点的前置节点
    x = zsl-&gt;header;
    for (i = zsl-&gt;level-1; i &gt;= 0; i--) {
        while (x-&gt;level[i].forward &amp;&amp;
               (x-&gt;level[i].forward-&gt;score &lt; sroce ||
                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;
                 compareStringObjects(x-&gt;level[i].forward-&gt;obj, obj) &lt; 0))) {
            x = x-&gt;level[i].forward;       
         }
         update[i] = x;
    }
    
    // 将 x 置为要删除的目标节点
    x = x-&gt;level[0].forward;
    // 最终判断最终找到的节点是否为目标对象
    if (x &amp;&amp; score == x-&gt;score &amp;&amp; equalStringObjects(x-&gt;obj, obj)) {
        // 调用 deleteNode 删除对应节点，然后释放内存
        zslDeleteNode(zsl, x, update);
        zslFreeNode(x);
        return 1;
    }
    return 0; // not found
}

void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;
    for (i = 0; i &lt; zsl-&gt;level; i++) {
        // 如果层次低于或等于即将删除的节点，则更新指针以及跨度
        if (update[i]-&gt;level[i].forward == x) {
            update[i]-&gt;level[i].span += x-&gt;level[i].span - 1;
            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;
        }
        else {
            // 如果层次高于即将删除的节点，则直接减少一个跨度
            update[i]-&gt;level[i].span -= 1;
        }                
    }
    
    // 更新即将删除节点的指针
    if (x-&gt;level[0].forward) {
        x-&gt;level[0].forward-&gt;backward = x-&gt;backward;
    }
    else {
        zsl-&gt;tail = x-&gt;backward;
    }
    
    // 如果删除节点的高度是 skiplist 的最高高度，则尝试调整 skiplist 的高度
    while (zsl-&gt;level &gt; 1 &amp;&amp; 
           zsl-&gt;header-&gt;level[zsl-&gt;level - 1].forward == NULL)  {
        zsl-&gt;level--;
    }    
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="redis/dict.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="redis/intset.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="redis/dict.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="redis/intset.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
