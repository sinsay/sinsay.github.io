<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Framing - SinSay&#x27;s Note Book</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../about.html"><strong aria-hidden="true">1.</strong> About Me</a></li><li class="chapter-item expanded "><a href="../tokio.html"><strong aria-hidden="true">2.</strong> Tokio Tutirial (译)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tokio/tutorial-hello.html"><strong aria-hidden="true">2.1.</strong> Hello</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-spawning.html"><strong aria-hidden="true">2.2.</strong> Spawning</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-shared-state.html"><strong aria-hidden="true">2.3.</strong> Shared State</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-channel.html"><strong aria-hidden="true">2.4.</strong> Channel</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-io.html"><strong aria-hidden="true">2.5.</strong> I/O</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-framing.html" class="active"><strong aria-hidden="true">2.6.</strong> Framing</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-indepth.html"><strong aria-hidden="true">2.7.</strong> Async In Depth</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-select.html"><strong aria-hidden="true">2.8.</strong> Select</a></li><li class="chapter-item expanded "><a href="../tokio/tutorial-streams.html"><strong aria-hidden="true">2.9.</strong> Streams</a></li></ol></li><li class="chapter-item expanded "><a href="../db/index.html"><strong aria-hidden="true">3.</strong> Database Internals</a></li><li class="chapter-item expanded "><a href="../data_struct.html"><strong aria-hidden="true">4.</strong> DataStruct</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../redis/sds.html"><strong aria-hidden="true">4.1.</strong> sds</a></li><li class="chapter-item expanded "><a href="../redis/dict.html"><strong aria-hidden="true">4.2.</strong> dict</a></li><li class="chapter-item expanded "><a href="../redis/skiplist.html"><strong aria-hidden="true">4.3.</strong> skiplist</a></li><li class="chapter-item expanded "><a href="../redis/intset.html"><strong aria-hidden="true">4.4.</strong> intset</a></li><li class="chapter-item expanded "><a href="../redis/ziplist.html"><strong aria-hidden="true">4.5.</strong> ziplist</a></li></ol></li><li class="chapter-item expanded "><a href="../redis.html"><strong aria-hidden="true">5.</strong> Redis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../redis/1.redis-basic.html"><strong aria-hidden="true">5.1.</strong> 基本定义</a></li><li class="chapter-item expanded "><a href="../redis/2.redis-analyse.html"><strong aria-hidden="true">5.2.</strong> 分析起步</a></li><li class="chapter-item expanded "><a href="../redis/3.redis-process.html"><strong aria-hidden="true">5.3.</strong> 请求处理</a></li><li class="chapter-item expanded "><a href="../redis/4.redis-execute.html"><strong aria-hidden="true">5.4.</strong> 执行命令</a></li></ol></li><li class="chapter-item expanded "><a href="../distributed.html"><strong aria-hidden="true">6.</strong> Distributed</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../distributed/mapreduce_note.html"><strong aria-hidden="true">6.1.</strong> MapReduce (译)</a></li><li class="chapter-item expanded "><a href="../distributed/raft_note.html"><strong aria-hidden="true">6.2.</strong> Raft (译)</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">SinSay&#x27;s Note Book</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#framing" id="framing">Framing</a></h2>
<p>我们现在来将我们上一章学到的 I/O 相关的知识用来实现 Mini-Redis 的帧模块。帧模块将字节流进行处理并转换为一个个的数据帧，每个帧表示了两端之间数据传输的命令单元。Redis 协议的帧如下所示</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bytes::Bytes;

enum Frame {
  Simple(String),
  Error(String),
  Integer(u64),
  Bulk(Bytes),
  Null,
  Array&lt;Vec&lt;Frame&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>帧的结构并不能代表任何语义，因为具体的命令解析跟实现是在更上一层做的，对于 HTTP 来说，一个帧看起来像这样</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum HttpFrame {
  RequestHead: {
    method: Method,
    uri: Uri,
    version: Version,
    headers: HeaderMap,
  },
  ResponseHead {
    status: StatusCode,
    version: Version,
    headers: HeaderMap,
  },
  BodyChunk {
    chunk: Bytes
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>为了实现 Mini-Redis 的帧，我们会实现一个 <code>Connection</code> 结构，他对 <code>TcpStream</code> 以及 <code>mini_redis::Frame</code> 的读取跟写入进行了封装。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mini_redis::{Frame, Result};
use tokio::net::TcpStream;

struct Connection {
    stream: TcpStream,
    // ... other fields here
}

impl Connection {
    /// Read a frame from the connection
    ///
    /// Returns `None` if EOF is reached
    pub async fn read_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;&gt; {
        Ok(None)
    }

    // Write a frame to the connection
    pub async fn write_frame(&amp;mut self, frame: &amp;Frame) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>对于具体的 Redis 协议可以参考 <a href="https://redis.io/topics/protocol">这里</a>， 完整的 <code>Connection</code> 代码可以从 <a href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/connection.rs">这里</a> 找到。</p>
<h3><a class="header" href="#buffered-reads" id="buffered-reads">Buffered Reads</a></h3>
<p><code>read_frame</code> 函数会执行到从 <code>stream</code> 读取到一个完整的帧之后才返回，因为一个单独的 <code>TcpStream::read</code> 调用返回指定数量的数据，所以他可能返回一个完整的帧、部分的帧或者是多个帧，如果读取到了部分的帧，数据将被缓存起来，然后尝试继续从套接字中继续读取；如果收到了多个帧，第一个帧会马上返回并且剩余的数据会缓存起来，直到下一次的 <code>read_frame</code> 调用。</p>
<p>为了实现 <code>Connection</code> 我们需要一个读取缓存的字段，数据从套接字中读取到缓存中，当数据能够组成一个帧时，该帧对应的数据会从缓存中删除。</p>
<p>我们会使用 <code>BytesMut</code> 作为缓存类型，这是一个跟 <code>Bytes</code> 一样但允许修改的类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Read a frame from the connection
///
/// Returns `None` if EOF is reached
pub async fn read_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;&gt; {
  loop {
    // Attempt to parse a frame from the buffered data. If
    // enough data has been buffered, the frame is
    // returned.
    if let Some(frame) = self.parse_frame()? {
      return Ok(Some(frame));
    }

    // There is not enough buffered data to read a frame.
    // Attempt to read more data from the socket.
    //
    // On success, the number of bytes is returned. `0`
    // indicates `end of stream'.
    if 0 == self.stream.read_buf(&amp;mut self.buffer).await? {
      return if self.buffer.is_empty() {
        Ok(None)
      } else {
        Err(&quot;Connection reset by peer&quot;.into())
      }
    }
  }
  Ok(None)
}
<span class="boring">}
</span></code></pre></pre>
<p>接着来逐步分解代码，<code>read_frame</code> 函数中的处理都处于 <code>loop</code> 循环内，第一步会尝试调用 <code>self.parse_frame()</code> 去从缓存 <code>self.buffer</code> 中解析出 Redis 的帧，如果缓存中的数据足够组成一个帧，则马上返回解析出来的帧。否则的话则尝试从套接字中读取更多的数据到缓存中，然后在下一个循环中继续尝试调用 <code>parse_frame</code>，如果这时数据足够了，则解析帧的操作就能够成功。</p>
<p>当从数据流中读取数据时，返回值 <code>0</code> 用来确认是否已经没有数据可以继续从套接字中读取了，如果这时缓存中仍有数据，说明我们读取到了部分的帧并且连接已经被意外中断了，当出现这种情况时 <code>read_frame</code> 会返回一个 <code>Err</code> 错误。</p>
<h3><a class="header" href="#the-buf-trait" id="the-buf-trait">The <code>Buf</code> Trait</a></h3>
<p>当从数据流中进行读取时会调用 <code>read_buf</code> ，当前版本的读取函数是由 <code>bytes</code> 包的 <code>BufMut</code> 类型实现的。</p>
<p>现在来考虑一下怎么同时在循环中通过 <code>read()</code> 来实现一样的功能， 先用 <code>Vec&lt;u8&gt;</code> 来替换掉 <code>BytesMut</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::net::TcpStream;

pub struct Connection {
  stream: TcpStream,
  buffer: Vec&lt;u8&gt;,
  cursor: usize,
}

impl Connection {
  pub fn new(stream: TcpStream) -&gt; Connection {
    Connection {
      stream,
      buffer: vec![0; 4096],
      cursor: 0,
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后是 <code>read_frame</code> 函数的实现</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Read a frame from the connection
///
/// Returns `None` if EOF is reached
pub async fn read_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;&gt; {
  loop {
    // Attempt to parse a frame from the buffered data. If
    // enough data has been buffered, the frame is
    // returned.
    if let Some(frame) = self.parse_frame()? {
      return Ok(Some(frame));
    }

    // Ensure the buffer has capacity
    if self.buffer.len() == self.cursor {
      // Grow the buffer
      self.buffer.resize(self.cursor * 2, 0);
    }

    // Read into the buffer, tracking the number
    // of bytes read
    let n = self.stream.read(&amp;mut self.buffer[self.cursor..]).await?;

    if 0 == n {
      return if self.cursor == 0 {
        Ok(None)
      } else {
        Err(&quot;Connection reset by peer&quot;.into())
      };
    } else {
      self.cursor += n;
    }
  }
}
<span class="boring">}
</span></code></pre></pre>
<p>使用字节数组跟 <code>read</code> 来实现功能，我们需要自己管理游标来跟踪当前已经缓存的数据量，确保只把缓存中的未使用区域传递给 <code>read()</code>，否则的话会导致缓存被覆盖。如果缓存被填满了，我们需要扩充缓存的大小用来填充更多的数据。在 <code>parse_frame()</code> 中，我们需要用到缓存中 <code>self.buffer[..self.cursor]</code> 的区域。</p>
<p>因为结对使用字节数组与游标是很常用的方式，<code>bytes</code> 包提供了对他们进行了抽象提取，最后以 <code>Buf Trait</code> 提供了数据读取及 <code>ByteMut Trait</code> 提供了数据写入的能力。当传递了一个 <code>T: BufMut</code> 类型给 <code>read_buf()</code> 函数时，该类型内部的游标会由 <code>read_buf</code> 更新。 因此在我们之前实现的 <code>read_frame</code> 版本中不需要自己来管理游标信息。</p>
<p>另外，在使用 <code>Vec&lt;u8&gt;</code> 时我们还需要对其进行初始化， <code>vec![0; 4096]</code> 分配了 4096 个字节的数组并将每个字节使用了 0 来进行填充，当扩充缓存的大小时，扩充部分的数据也需要使用 0 来进行填充。这个初始化的过程并不是没有代价的，但在使用 <code>BytesMut</code> 跟 <code>BufMut</code> 时，缓存的容量是未初始化的， <code>BytesMut</code> 抽象能够防止我们读取未初始化的内存，因此得以让我们避免了初始化这一步。</p>
<h3><a class="header" href="#parsing" id="parsing">Parsing</a></h3>
<p>现在让我们来看一下 <code>parse_frame()</code> 函数，解析的操作分成了两步来实现</p>
<ol>
<li>确认缓存中包含了完整的帧并找到该帧所在最后一个字节的位置</li>
<li>解析该帧</li>
</ol>
<p><code>mini-redis</code> 包为我们要做的两步都提供了对应的函数</p>
<ol>
<li><code>Frame::check</code></li>
<li><code>Frame::parse</code></li>
</ol>
<p>我们会继续使用 <code>Buf</code> 抽象来简化操作，因此会将一个 <code>Buf</code> 传递给 <code>Frame::check</code> ，当 <code>check</code> 函数迭代传递给它的缓存时，他内部的游标会被往前移动，当 <code>check</code> 函数返回时，缓存内部的游标会指向该帧的最后一个位置。</p>
<p>然后我们会使用 <code>std::io::Cursor&lt;&amp;[u8]&gt;</code> 得到一个 <code>Buf</code> 类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mini_redis::{Frame, Result};
use mini_redis::frame::Error::Incomplete;
use bytes::Buf;
use std::io::Cursor;

fn parse_frame(&amp;mut self) -&gt; Result&lt;Option&lt;Frame&gt;&gt; {
  // Create the `T: Buf` type
  let mut buf = Cursor::new(&amp;self.buffer[..]);

  // Check whether a full frame is available
  match Frame::check(&amp;mut buf) {
    Ok(_) =&gt; {
      // Get the byte length of the frame
      let len = buf.position() as usize;

      // Reset the internal cursor for the
      // call to `parse`
      buf.set_position(0);

      // Parse the frame
      let frame = Frame::parse(&amp;mut buf)?;

      // Discard the frame from the buffer
      self.buffer.advance(len);

      Ok(Some(frame))
    }
    Err(Incomplete) =&gt; Ok(None),
    Err(e) =&gt; Err(e.into()),
  }

<span class="boring">}
</span></code></pre></pre>
<p>完整的 <code>Frame::check</code> 函数可以在 <a href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/frame.rs#L63-L100">这里</a> 找到，在这里我们不会讨论他的具体实现。</p>
<p>这里要注意的是 <code>Buf</code> 被看为了一个 &quot;字节迭代器&quot; 风格的接口来使用，这些接口会获取其中的数据并往前移动其游标。比如解析帧时，第一个字节会被用来作为帧的类型进行检查，最后内部使用 <code>Buf::get_u8</code> 来获取数据及移动游标信息。</p>
<p><code>Buf Trait </code> 还提供了其他许多有用的接口，具体的可以查阅其 <a href="https://docs.rs/bytes/1/bytes/buf/trait.Buf.html">接口文档</a>。</p>
<h3><a class="header" href="#buffered-writes" id="buffered-writes">Buffered Writes</a></h3>
<p>另一部分处理帧的函数是 <code>write_frame(frame)</code>，这个函数将整个帧的数据写到套接字中，为了最小化 <code>write</code> 系统调用，写入的数据也会被缓存起来，写入的帧被编码后会缓存起来直到最后一起写入套接字，然而，不像 <code>read_frame</code> 函数，整个帧并不总是能够在写入套接字前缓存起来。</p>
<p>考虑一个批量的数据流帧，他被写入的数据是 <code>Frame::Bulk(Bytes)</code> 类型。写入的数据类型是一个帧的头部，该头部以 <code>$</code> 字符开头，后接剩余的字节数据长度。该帧的主要部分是他的内容 <code>Bytes</code> 的值，如果数据太大，复制他们到中间的缓存区域将会是一个比较大的开销。</p>
<p>为了实现缓存的写入，我们会使用 <code>BufWriter</code> 类型，该类型有一个实现了 <code>T: AsyncWrite</code> 的类型进行初始化，同时他自身也实现了 <code>AsyncWrite</code>。当他的 <code>write</code> 函数被调用时，该写入操作并不会直接的传递给内部的写入器，而是会写到缓存中。在缓存被填满时，缓存的内容才会被写入到其内部的写入器，然后缓存的内容会被清空，这里面还有一些允许绕过缓存区的优化。</p>
<p>我们不会在教程中尝试完整的实现 <code>write_frame()</code>，完整的代码可以从 <a href="https://github.com/tokio-rs/mini-redis/blob/tutorial/src/connection.rs#L159-L184">这里</a> 获取到。</p>
<p>首先， <code>Connection</code> 类型被更新为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::io::BufWriter;
use tokio::net::TcpStream;
use bytes::BytesMut;

struct Connection {
    stream: BufWriter&lt;TcpStream&gt;,
    buffer: BytesMut, // ... other fields here
}

impl Connection {
    pub fn new(stream: TcpStream) -&gt; Connection {
        Connection {
            stream: BufWriter::new(stream),
            buffer: BytesMut::with_capacity(4096),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后 <code>write_frame()</code> 被实现为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::io::{self, AsyncWriteExt};
use mini_redis::Frame;

async fn write_frame(&amp;mut self, frame: &amp;Frame)
-&gt; io::Result&lt;()&gt;
{
  match frame {
    Frame::Simple(val) =&gt; {
      self.stream.write_u8(b'+').await?;
      self.stream.write_all(val.as_bytes()).await?;
      self.stream.write_all(b&quot;\r\n&quot;).await?;
    }
    Frame::Error(val) =&gt; {
      self.stream.write_u8(b'-').await?;
      self.stream.write_all(val.as_bytes()).await?;
      self.stream.write_all(b&quot;\r\n&quot;).await?;
    }
    Frame::Integer(val) =&gt; {
      self.stream.write_u8(b':').await?;
      self.write_decimal(*val).await?;
    }
    Frame::Null =&gt; {
      self.stream.write_all(b&quot;$-1\r\n&quot;).await?;
    }
    Frame::Bulk(val) =&gt; {
      let len = val.len();

      self.stream.write_u8(b'$').await?;
      self.write_decimal(len as u64).await?;
      self.stream.write_all(val).await?;
      self.stream.write_all(b&quot;\r\n&quot;).await?;
    }
    Frame::Array(_val) =&gt; unimplemented!(),
  }

  self.stream.flush().await;

  Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p>该函数使用了 <code>AsyncWriteExt</code> 提供的功能，他同样也能使用 <code>TcpStream</code> 来调用，但这样的话就没办法在写入时使用到中间的缓存区域了。</p>
<ul>
<li><code>write_u8</code> 写入一个单独的字节</li>
<li><code>write_all</code> 写入所有的数据</li>
<li><code>write_decimal</code> 则是有 mini-redis 所实现</li>
</ul>
<p>该函数最后还要调用 <code>self.stream.flush().await</code> ，因为对 <code>BufWriter</code> 会将写入的数据缓存起来， <code>write</code> 操作并不能保证数据会写入到套接字，在返回前，我们希望帧的所有数据都会被写入到套接字中，所以通过 <code>flush</code> 函数实现将所有的数据写入到套接字。</p>
<p>另一个选择是不在 <code>write_frame()</code> 中调用 <code>flush()</code>，而是为 <code>Connection</code> 类型提供一个 <code>flush()</code> 函数，这将允许调用者将多个较小的帧缓存起来，最后使用一个 <code>write</code> 系统调用一次性将他们写入套接字。这个实现会让 <code>Connection</code> 变的复杂一些，简单是 Mini-Redis 的目标之一，所以我们选在直接将 <code>flush().await</code> 的调用直接写到了 <code>write_frame()</code> 里。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../tokio/tutorial-io.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../tokio/tutorial-indepth.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../tokio/tutorial-io.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../tokio/tutorial-indepth.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
