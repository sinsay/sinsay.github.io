<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async In Depth - SinSay's Note Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="about.html"><strong aria-hidden="true">1.</strong> About Me</a></li><li><a href="tokio.html"><strong aria-hidden="true">2.</strong> Tokio Tutirial (译)</a></li><li><ol class="section"><li><a href="tokio/tutorial-hello.html"><strong aria-hidden="true">2.1.</strong> Hello</a></li><li><a href="tokio/tutorial-spawning.html"><strong aria-hidden="true">2.2.</strong> Spawning</a></li><li><a href="tokio/tutorial-shared state.html"><strong aria-hidden="true">2.3.</strong> Shared State</a></li><li><a href="tokio/tutorial-channel.html"><strong aria-hidden="true">2.4.</strong> Channel</a></li><li><a href="tokio/tutorial-io.html"><strong aria-hidden="true">2.5.</strong> I/O</a></li><li><a href="tokio/tutorial-framing.html"><strong aria-hidden="true">2.6.</strong> Framing</a></li><li><a href="tokio/tutorial-indepth.html" class="active"><strong aria-hidden="true">2.7.</strong> Async In Depth</a></li><li><a href="tokio/tutorial-select.html"><strong aria-hidden="true">2.8.</strong> Select</a></li></ol></li><li><a href="data_struct.html"><strong aria-hidden="true">3.</strong> DataStruct</a></li><li><ol class="section"><li><a href="redis/sds.html"><strong aria-hidden="true">3.1.</strong> sds</a></li><li><a href="redis/dict.html"><strong aria-hidden="true">3.2.</strong> dict</a></li><li><a href="redis/skiplist.html"><strong aria-hidden="true">3.3.</strong> skiplist</a></li><li><a href="redis/intset.html"><strong aria-hidden="true">3.4.</strong> intset</a></li><li><a href="redis/ziplist.html"><strong aria-hidden="true">3.5.</strong> ziplist</a></li></ol></li><li><a href="redis.html"><strong aria-hidden="true">4.</strong> Redis</a></li><li><ol class="section"><li><a href="redis/1.redis-basic.html"><strong aria-hidden="true">4.1.</strong> 基本定义</a></li><li><a href="redis/2.redis-analyse.html"><strong aria-hidden="true">4.2.</strong> 分析起步</a></li><li><a href="redis/3.redis-process.html"><strong aria-hidden="true">4.3.</strong> 请求处理</a></li><li><a href="redis/4.redis-execute.html"><strong aria-hidden="true">4.4.</strong> 执行命令</a></li></ol></li><li><a href="distributed.html"><strong aria-hidden="true">5.</strong> Distributed</a></li><li><ol class="section"><li><a href="distributed/mapreduce_note.html"><strong aria-hidden="true">5.1.</strong> MapReduce (译)</a></li><li><a href="distributed/raft_note.html"><strong aria-hidden="true">5.2.</strong> Raft (译)</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">SinSay's Note Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="tokio/tutorial-indepth.html#async-in-depth" id="async-in-depth"><h1>Async In Depth</h1></a>
<p>现在，我们已经对 Rust 异步方式跟 Tokio 有了比较全面的了解，接着我们将继续更加深入的来挖掘 Rust 的异步运行时模型。在我们前面的教程中，我们提到了 Rust 使用了一种特殊的方式来实现异步的目标，现在我们来说说他到底是什么方式。</p>
<a class="header" href="tokio/tutorial-indepth.html#futures" id="futures"><h2>Futures</h2></a>
<p>现在让我们来看一个非常简单的异步函数作为整体的概览，这个函数相对于我们已经完成的教程并没有任何新的东西</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use tokio::net::TcpStream;

async fn my_async_fn() {
  println!(&quot;hello from async&quot;);
  let _socket = TcpStream::connect(&quot;127.0.0.1:3000&quot;).await.unwrap();
  println!(&quot;async TCP operation complete&quot;);
}
#}</code></pre></pre>
<p>然后我们来调用这个函数得到他的返回值，然后在返回值上调用 <code>.await</code></p>
<pre><pre class="playpen"><code class="language-rust">#[tokio::main]
async fn main() {
  let waht_is_this = my_async_fn();
  // Nothing has been printed yet.
  what_is_this.await;
  // Text has been printed and socket has been
  // established and closed.
}
</code></pre></pre>
<p><code>my_async_fn()</code> 的返回值是一个 <code>Future</code>, 每个 <code>Future</code> 都会实现标准库提供的 <code>std::future::Future Trait</code>，他们表示了一个值，该值包含了进程内的异步计算。</p>
<p><code>std::future::Future Trait</code> 的定义如下：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::pin::Pin;
use std::task::{Context, Poll};

pub trait Future {
  type Output;
  
  fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context )
      -&gt; Poll&lt;Self::Output&gt;; 
}
#}</code></pre></pre>
<p>在 Trait 中定义的关联类型 <code>Output</code> 表示该 Future 在完成时会产生的结果，而 <code>Pin</code> 类型则是 Rust 用来支持异步操作中借用机制的基础。具体的细节可以从标准库的 <a href="https://doc.rust-lang.org/std/pin/index.html">文档</a> 了解。</p>
<p>跟其他编程语言实现 <code>Future</code> 的方式不同，Rust 的 <code>Future</code> 并不表示任何跟后台执行相关的含义，他只表示了该计算原本的过程。持有 <code>Future</code> 的人需要负责的是通过调用 <code>Future::poll</code> 函数，来让该计算能够继续推进，该推进的过程则称为 <code>Polling</code>。</p>
<a class="header" href="tokio/tutorial-indepth.html#implementing-future" id="implementing-future"><h3>Implementing <code>Future</code></h3></a>
<p>现在让我们来实现一个包含下面功能的简单的 <code>Future</code></p>
<ol>
<li>等待指定的时间</li>
<li>打印文本到标准输出</li>
<li>返回一个字符串</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

struct Delay {
  when: Instant,
}

impl Future for Delay {
  type Output = &amp;'static str;
  
  fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
      -&gt; Pool&lt;&amp;'static str&gt; {
        if Instant::now() &gt; self.when {
          println!(&quot;Hello world&quot;);
          Poll::Ready(&quot;done&quot;)
        } else {
          // Ignore this line for now
          cx.waker().wake_by_ref();
          Poll::Pending
        }
  }
}

#[tokio::main]
async fn main() {
  let when = Instant::now() + Duration::from_millis(10);
  let future = Delay { when };
  
  let out = future.await;
  asser_eq!(out, &quot;done&quot;);
}
</code></pre></pre>
<a class="header" href="tokio/tutorial-indepth.html#async-fn-as-a-future" id="async-fn-as-a-future"><h3>Async fn as a Future</h3></a>
<p>在 <code>main</code> 函数中，我们初始化了一个 <code>Future</code> 并调用了其 <code>.await</code>，在异步的函数中，我们可以在任何实现了 <code>Future Trait</code> 的值上调用 <code>.await</code>。实际上，调用一个标记为 <code>async</code> 的函数会返回一个匿名的实现了 <code>Future</code> 的值，在 <code>async fn main()</code> 函数中，该调用生成的 <code>Future</code> 类似下面的代码段</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};

enum MainFuture {
  // Initialized, never polled
  State0,
  // Waiting on `Delay`, i.e. the `future.await` line
  State1(Delay),
  // The future has completed.
  Terminater,
}

impl Future for MainFuture {
  type Output = ();
  
  fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)-&gt; Poll&lt;()&gt; {
    use MainFutures::*;

    loop {
      match *self {
        State0 =&gt; {
          let when = Instant::now() + Duration::from_millis(10);
          let future = Delay { when };
          *self = State1(future);
        }
        State1(ref mut my_future) =&gt; {
          match Pin::new(my_future).poll(cx) {
            Poll::Ready(out) =&gt; {
              assert_eq(out, &quot;done&quot;);
              *self = Terminated;
              return Poll::Ready(());
            }
            Poll::Pending =&gt; {
              return Poll::Pending;
            }
          }
        }
        Terminated =&gt; {
          panic!(&quot;future polled after completion&quot;)
        }
      }
    }
  }
}
#}</code></pre></pre>
<p>Rust 的 <code>Futures</code> 被实现成了状态机，在上面的代码中 <code>MainFuture</code> 用一个枚举来表示该 <code>Future</code> 所具有的所有状态。一开始该 <code>Future</code> 被置为了 <code>State0</code>，当 <code>poll</code> 被调用时，该 <code>Future</code> 尝试让自己的状态进入下一步，即 <code>State1</code>，在这一状态中会继续尝试让自己内部的状态 <em>(Delay)</em> 也进入下一步。当该 <code>Future</code> 的异步操作完成时，他会将最终的返回结果与 <code>Poll::Ready</code> 一起返回。</p>
<p>如果该 <code>Future</code> 现在无法完成，这一般取决于其内部所依赖的其他资源是否完成，他会返回 <code>Poll::Pending</code>，调用者收到 <code>Poll::Pending</code> 便能够确认该 <code>Future</code> 现在无法继续推进，因此调用者会在稍后继续尝试调用 <code>poll</code> 函数来推进其状态。</p>
<p>我们通常会看到 <code>Future</code> 由其他的一些 <code>Future</code> 组成，调用最外层的 <code>Future</code> 会导致内部的 <code>Future</code> 的 <code>poll</code> 函数也被调用。</p>
<a class="header" href="tokio/tutorial-indepth.html#executors" id="executors"><h2>Executors</h2></a>
<p>异步的 Rust 函数会返回 <code>Future</code>，而 <code>Future</code> 需要有人来调用他的 <code>poll</code> 函数以推进他的状态，并且 <code>Future</code> 经常会由许多其他的 <code>Future</code> 组成，现在的问题就在于：谁来调用最外层 <code>Future</code> 的 <code>poll</code> 函数？</p>
<p>回顾之前信息，为了运行一个异步的函数，我们要么把他传递给 <code>tokio::spawn</code> 要么就给 <code>main</code> 函数标注上 <code>#[tokio::main]</code> 宏。该宏会将最终生成的 <code>Future</code> 传递给 <code>Tokio</code> 的执行器 <em>(Executor)</em>。执行器会负责来调用最外层的 <code>Future::poll</code>函数，驱动整个异步操作的进行。</p>
<a class="header" href="tokio/tutorial-indepth.html#mini-tokio" id="mini-tokio"><h3>Mini Tokio</h3></a>
<p>为了更好的理解这些知识，并将他们都整合起来，我们来实现一个迷你的 Tokio。完整的代码可以从 <a href="https://github.com/tokio-rs/website/blob/master/tutorial-code/mini-tokio/src/main.rs">这里</a> 找到。</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::VecDeque;
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use futures::task;

fn main() {
    let mut mini_tokio = MiniTokio::new();

    mini_tokio.spawn(async {
        let when = Instant::now() + Duration::from_millis(10);
        let future = Delay { when };

        let out = future.await;
        assert_eq!(out, &quot;done&quot;);
    });

    mini_tokio.run();
}

struct MiniTokio {
    tasks: VecDeque&lt;Task&gt;,
}

type Task = Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + Send&gt;&gt;;

impl MiniTokio {
    fn new() -&gt; MiniTokio {
        MiniTokio {
            tasks: VecDeque::new(),
        }
    }
    
    /// Spawn a future onto the mini-tokio instance.
    fn spawn&lt;F&gt;(&amp;mut self, future: F)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        self.tasks.push_back(Box::pin(future));
    }
    
    fn run(&amp;mut self) {
        let waker = task::noop_waker();
        let mut cx = Context::from_waker(&amp;waker);
        
        while let Some(mut task) = self.tasks.pop_front() {
            if task.as_mut().poll(&amp;mut cx).is_pending() {
                self.tasks.push_back(task);
            }
        }
    }
}
</code></pre></pre>
<p>上面会运行整个异步的代码， <code>Delay</code> 的实例会被创建并且等待其执行完成，只是现在的实现有一个很大的问题。当前的执行器在遇到未能完成的任务时不会挂起或进入睡眠，而是会不断的循环调用所有已创建的任务的 <code>poll</code>，但是在大部分的情况下，这些 <code>Future</code> 在返回 <code>Poll::Pending</code> 后并不会马上完成，继续的调用只会不断的返回 <code>Poll::Pending</code>，当前的实现会极大的消耗 CPU 资源。</p>
<p>理想情况下，我们希望 mini-tokio 只在有 <code>Future</code> 能够继续推进其状态时进行 <code>Poll</code>，这种情况发生在任务内部的某些资源操作完成时，比如一个任务希望从 TCP 套接字中读取数据，那就应该只在 TCP 套接字接收到数据的时候才进行 <code>poll</code>，在我们的案例中任务会被 <code>Instant</code> 实例堵塞，理想情况下，我们希望 mini-tokio 只在 <code>Instant</code> 指定的时间过去后才对任务进行 <code>Poll</code>。</p>
<p>为了实现这个目标，当一个资源在还没就绪的状态下被 <code>Poll</code> 时，他应该在自身就绪时发出通知。</p>
<a class="header" href="tokio/tutorial-indepth.html#wakers" id="wakers"><h3>Wakers</h3></a>
<p>到现在我们还没讨论到 <code>Waker</code>，他是资源在可用时用来通知那些等待中的任务的系统，接收到通知的任务意味着他们能够继续进行后续的操作。</p>
<p>让我们再来看一次 <code>Future::poll</code> 的定义</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
#}</code></pre></pre>
<p><code>poll</code> 函数的 <code>Context</code> 类型参数中有个 <code>waker()</code> 函数，该函数会返回一个跟当前任务绑定的 <code>Waker</code>，这个 <code>Waker</code> 有一个 <code>wake()</code> 函数，调用这个函数就能够通知执行器，执行器会调度与该 <code>Wakier</code> 关联的任务，让他继续执行。资源在他就绪的时候就会调用 <code>wake()</code> 通知执行器让他继续对这个任务调用 <code>poll</code>。</p>
<a class="header" href="tokio/tutorial-indepth.html#update-delay" id="update-delay"><h3>Update <code>Delay</code></h3></a>
<p>现在将 <code>Delay</code> 更新为使用 <code>Waker</code> 的方式</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::time::{Duration, Instant};
use std::thread;

struct Delay {
  when: Instant,
}

impl Future for Delay {
  type Output = &amp;'static str;
  
  fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;&amp;'static str&gt; {
    if Instant::now() &gt;= self.when {
      println!(&quot;Hello world&quot;);
      Poll::Ready(&quot;done&quot;)
    } else {
      // Get a handle to the waker for the current task
      let waker = cx.waker().clone();
      let when = self.when;
      
      // Spawn a timer thread
      thread::spawn(move || {
        let now = Instant::now();
        
        if now &lt; when {
          thread::sleep(when - now);
        }
        
        waker.wake();
      });
      
      Poll::Pending
    }
  }
}
#}</code></pre></pre>
<p>现在，当等待的时间到达后，调用的任务会收到通知，然后执行器就能够确认该任务能够继续调度执行了。下一步我们要来更新 mini-tokio 让他来监听通知信息。</p>
<p>这里的 <code>Delay</code> 实现还是有一些问题，我们稍后会一起修复。</p>
<blockquote>
<p>当一个 <code>Future</code> 返回 <code>Poll::Pending</code> 时，他要 <strong>确保</strong> 执行器能够在稍后的某个时间点收到通知，如果无法保证这点，该任务会无限的挂起导致无法运行。</p>
<p>返回 <code>Poll::Pending</code> 之后没有调用 <code>wake</code> 发送通知是一个很常见的错误。</p>
</blockquote>
<p>回顾一下最初的 <code>Delay</code> 实现，下面是 <code>Future</code> 在 <code>Delay</code> 上的实现</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Future for Delay {
    type Output = &amp;'static str;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;)
        -&gt; Poll&lt;&amp;'static str&gt;
    {
        if Instant::now() &gt;= self.when {
            println!(&quot;Hello world&quot;);
            Poll::Ready(&quot;done&quot;)
        } else {
            // Ignore this line for now.
            cx.waker().wake_by_ref();
            Poll::Pending
        }
    }
}
#}</code></pre></pre>
<p>在返回 <code>Poll::Pending</code> 之前，我们调用了 <code>cx.waker().wake_by_ref()</code>，这是为了满足实现 <code>Future</code> 的约定，因为我们需要负责向 <code>Waker</code> 发送通知。又因为我们没有专门实现一个定时器的管理线程，所以才直接在 <code>Poll::Pending</code> 前直接发送通知。调用之后的结果就是，我们的 <code>Future</code> 能够马上被重新调度，重新执行，虽然不代表能够马上完成任务、结束等待。</p>
<p>从上面的例子能够发现，不是只有在资源就绪的时候才能发送通知给 <code>Waker</code>，我们在不能够继续执行下去的状态仍然发送了通知给 <code>Wakter</code>，除了消耗更多的 CPU 以外这并不会造成什么问题，因为他只是导致了更多的循环调用。</p>
<a class="header" href="tokio/tutorial-indepth.html#updating-mini-tokio" id="updating-mini-tokio"><h3>Updating Mini Tokio</h3></a>
<p>接下来我们要更新 Mini Tokio 的实现，让他能够接收到消息通知，我们希望执行器只有在任务就绪的情况才去执行他，因此 Mini Tokio 将会提供自己的 <code>Waker</code> 实现。当 <code>Waker</code> 被唤醒时，需要被执行的任务会被先排到队列中等待，然后 Mini Tokio 在 <code>Poll</code> 这个任务的时候会把对应的 <code>Waker</code> 传递给他。</p>
<p>更新后的 Mini Tokio 会使用 Channel 来存储调度的任务，Channel 可以让来自不同线程的任务在其中排队，因此 <code>Waker</code> 必须要实现 <code>Send</code> 跟 <code>Sync</code> 才能够在不同的线程中传递，才能够在我们即将使用的 <code>crossbeam</code> 包中的 Channel 中使用，不使用标准库的是因为标准库中的 Channel 是非 <code>Sync</code> 的。</p>
<blockquote>
<p><code>Sync</code> 跟 <code>Send</code> Trait 是用在 Rust 并发编程中的标志性的 Trait。一个实现了 <code>Send</code> 的类型说明他能够在不同的线程中被传递，大部分的类型都实现了 <code>Send</code>，当然也有少部分如 <code>Rc</code> 这些是没实现的。<code>Sync</code> 则说明类型能够被并行的访问其不可变引用。一个类型可以是 <code>Send</code> 但不是 <code>Sync</code> 的，比如 <code>Cell</code>，他可以使用不可变引用来进行修改，但不能够并发的被访问。</p>
<p>想要了解更多的细节的话，可以看 <a href="https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html">Rust Bokk 的这个章节</a>。</p>
</blockquote>
<p>接着添加新的依赖，让我们能够使用所需的 Channel。</p>
<pre><code class="language-toml">crossbeam = &quot;0.7&quot;
</code></pre>
<p>然后更新 Mini Tokio 的结构定义</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use crossbeam::channel;
use std::sync::Arc;

struct MiniTokio {
  scheduled: channel::Receiver&lt;Arc&lt;Task&gt;&gt;,
  sender: channel::Sender&lt;Arc&lt;Task&gt;&gt;,
}

struct Task {
  // This will be filled in soon.
}
#}</code></pre></pre>
<p><code>Waker</code> 是 <code>Sync</code> 并且能够被 <code>Clone</code> 的，当 <code>wake</code> 被调用时，当前的任务必须能够被重新调度去执行，为了实现这点，我们定义了一个 Channel，当 <code>wake()</code> 被调用时，这个任务被 Channel 的 <code>Sender</code> 发送出去。接着我们的 <code>Task</code> 任务类型会实行具体的唤醒逻辑，为了实现这点，<code>Task</code>需要包含创建的 <code>Future</code> 以及 Channel 的 <code>Sender</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::sync{Arc, Mutex};

struct Task {
  // The `Mutex` is to make `Task` implement `Sync`. Only
  // one thread accesses `future` at any given time. The
  // `Mutex` is not required for correctness. Real Tokio
  // does not use a mutex here, bu real Tokio has more
  // lines of code than can fit in a single tutorial page.
  future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output=()&gt; + Send&gt;&gt;&gt;,
  executor: channel::Sender&lt;Arc&lt;Task&gt;&gt;,
}

impl Task {
  fn schedule(self: &amp;Arc&lt;Self&gt;) {
    self.executor.send(self.clone());
  }
}
#}</code></pre></pre>
<p>为了调度该任务， 被 <code>Arc</code>  包装着的 <code>Task</code> 被发送 <code>Clone</code> 后发送到了 Channel 中，接着我们需要来实现对 <code>std::task::Waker</code> 的调度处理了。标准库为此提供了较为底层的 <a href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html">手动构造虚表</a> 的接口，这个做法为实现者提供了最大的灵活度，但同时也要求我们去实现大量的非安全代码，在这里我们使用了由 <code>futures</code> 包提供的 <code>ArcWake</code> 类型来替代复杂的 <a href="https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html"><code>RawWakerVTable</code></a> ，他让我们只需要简单的实现该 Trait 的方法，就能让 <code>Task</code> 成为一个 <code>Waker</code>。</p>
<p>首先到 <code>Cargo.toml</code> 添加我们对 <code>futures</code> 的依赖。</p>
<pre><code class="language-toml">futures = &quot;0.3&quot;
</code></pre>
<p>接着实现 <code>futures::task::ArcWake</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use futures::task::ArcWake;
use std::sync::Arc;

impl ArcWake for Task {
  fn wake_by_ref(arc_self: &amp;Arc&lt;Self&gt;) {
    arc_self.schedule();
  }
}
#}</code></pre></pre>
<p>当我们之前实现的计时器线程调用了 <code>waker.wake()</code> 时，该任务将会被发送到 Channel，然后我们的调度器的 <code>MiniTokio::run()</code> 函数会接收到该任务并执行他。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl MiniTokio {
    fn run(&amp;self) {
        while let Ok(task) = self.scheduled.recv() {
            task.poll();
        }
    }

    /// Initialize a new mini-tokio instance.
    fn new() -&gt; MiniTokio {
        let (sender, scheduled) = channel::unbounded();

        MiniTokio { scheduled, sender }
    }

    /// Spawn a future onto the mini-tokio instance.
    ///
    /// The given future is wrapped with the `Task` harness and pushed into the
    /// `scheduled` queue. The future will be executed when `run` is called.
    fn spawn&lt;F&gt;(&amp;self, future: F)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        Task::spawn(future, &amp;self.sender);
    }
}

impl Task {
    fn poll(self: Arc&lt;Self&gt;) {
        // Create a waker from the `Task` instance. This
        // uses the `ArcWake` impl from above.
        let waker = task::waker(self.clone());
        let mut cx = Context::from_waker(&amp;waker);

        // No other thread ever tries to lock the future
        let mut future = self.future.try_lock().unwrap();

        // Poll the future
        let _ = future.as_mut().poll(&amp;mut cx);
    }

    // Spawns a new taks with the given future.
    //
    // Initializes a new Task harness containing the given future and pushes it
    // onto `sender`. The receiver half of the channel will get the task and
    // execute it.
    fn spawn&lt;F&gt;(future: F, sender: &amp;channel::Sender&lt;Arc&lt;Task&gt;&gt;)
    where
        F: Future&lt;Output = ()&gt; + Send + 'static,
    {
        let task = Arc::new(Task {
            future: Mutex::new(Box::pin(future)),
            executor: sender.clone(),
        });

        let _ = sender.send(task);
    }

}
#}</code></pre></pre>
<p>上面的代码修改了许多的东西，首先 <code>MiniTokio::run</code> 的实现方式变更为使用一个循环不停的从 Channel 中接收已调度的任务。当任务能被唤醒时将会被放到 Channel，这样能够让 <code>MiniTokio::run</code> 能够让他继续的推进执行进度。</p>
<p>然后 <code>MiniTokio::new</code> 以及 <code>MiniTokio::spawn</code> 函数调整为使用 Channel 来替换 <code>VecDeque</code>。当新的任务被创建时，Channel 的 Sender 部分传递给任务保存，因此当任务能够继续推进时，能用它来将自己调度给运行时去执行。</p>
<p><code>Task::poll</code> 函数使用 <code>futures::task::ArcWake</code> 来便捷的创建 <code>Waker</code>，该 <code>Waker</code> 会被用来创建任务的上下文，该上下文信息会在之后调用 <code>poll</code> 的时候作为参数传递。</p>
<a class="header" href="tokio/tutorial-indepth.html#summary" id="summary"><h3>Summary</h3></a>
<p>到现在为止我们看到了一个用来说明 Rust 的异步系统是如何运行的完整例子，Rust 的 <code>async/await</code> 是通过 <code>Trait</code> 来进行支持实现的，如 <code>Future</code> 等，这让第三方的包，如 Tokio，能够通过他们来实现具体的细节。</p>
<ul>
<li>Rust 的异步操作是需要调用者通过 Poll 去推进的惰性操作</li>
<li><code>Waker</code> 被传递给 <code>Future</code> ， <code>Future</code>将使用他来任务进行关联</li>
<li>当资源未就绪时会返回 <code>Poll::Pending</code>，这时任务的 <code>Waker</code> 会被其记录下来</li>
<li>当资源就绪时，会使用已记录的 <code>Waker</code> 来发出通知</li>
<li>执行器接收到通知后会将对应的任务调度执行</li>
<li>任务被再次 <code>Poll</code>，因为资源此时已就绪所以这次执行能够推进任务的状态</li>
</ul>
<a class="header" href="tokio/tutorial-indepth.html#a一些零散的信息" id="a一些零散的信息"><h3>一些零散的信息</h3></a>
<p>回顾一下我们早前说的，<code>Delay</code> 还有一些问题需要修复，主要的问题在于 Rust 的异步模型允许一个 <code>Future</code> 在不同的任务中传递，我们来看看下面的代码</p>
<pre><pre class="playpen"><code class="language-rust">use futures::future::poll_fn;
use std::future::Future;
use std::pin::Pin;

#[tokio::main]
async fn main() {
  let when = Instant::now() + Duration::from_millis(10);
  let mut delay = Some(Delay { when });
  
  poll_fn(move |cx| {
    let mut delay = delay.take.unwrap();
    let res = Pin::new(&amp;mut delay).poll(cx);
    assert!(res.is_pending());
    tokio::spawn(async move {
      delay.await;
    });
  }).await;
}
</code></pre></pre>
<p><code>poll_fn</code> 使用一个闭包函数创建了一个 <code>Future</code> 实例，上面的代码段创建了一个 <code>Delay</code> 的实例，然后对其调用了一次 <code>poll</code>，然后又将其发送给了另外一个任务去调用 <code>.await</code> 进行等待。在这个例子中，<code>Delay::poll</code> 被调用了多次，并且是使用了 <strong>不同</strong> 的 <code>Waker</code> 实例。我们早先的实现没办法处理这种场景，他会导致创建的任务永远处于睡眠状态，因为最后是错误的任务收到了通知。</p>
<p>在实现 <code>Future</code> 时一个非常重要的点在于，每次调用 <code>poll</code> 传递的 <code>Waker</code> 可能并非同一个，<code>poll</code> 函数在被调用时需要将自己记录的 <code>Waker</code> 替换为新的那个。</p>
<p>为了修复这个问题，我们可以将代码改成下面这样</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::future::Future;
use std::pin::Pin;
use std::sync::{Arc, Mutex};
use std::task::{Context, Poll, Waker};
use std::thread;
use std::time::{Duration, Instant};

struct Delay {
    when: Instant,
    waker: Option&lt;Arc&lt;Mutex&lt;Waker&gt;&gt;&gt;,
}

impl Future for Delay {
    type Output = ();

    fn poll(mut self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;()&gt; {
        // First, if this is the first time the future is called, spawn the
        // timer thread. If the timer thread is already running, ensure the
        // stored `Waker` matches the current task's waker.
        if let Some(waker) = &amp;self.waker {
            let mut waker = waker.lock().unwrap();

            // Check if the stored waker matches the current task's waker.
            // This is necessary as the `Delay` future instance may move to
            // a different task between calls to `poll`. If this happens, the
            // waker contained by the given `Context` will differ and we
            // must update our stored waker to reflect this change.
            if !waker.will_wake(cx.waker()) {
                *waker = cx.waker().clone();
            }
        } else {
            let when = self.when;
            let waker = Arc::new(Mutex::new(cx.waker().clone()));
            self.waker = Some(waker.clone());

            // This is the first time `poll` is called, spawn the timer thread.
            thread::spawn(move || {
                let now = Instant::now();

                if now &lt; when {
                    thread::sleep(when - now);
                }

                // The duration has elapsed. Notify the caller by invoking
                // the waker.
                let waker = waker.lock().unwrap();
                waker.wake_by_ref();
            });
        }

        // Once the waker is stored and the timer thread is started, it is
        // time to check if the delay has completed. This is done by
        // checking the current instant. If the duration has elapsed, then
        // the future has completed and `Poll::Ready` is returned.
        if Instant::now() &gt;= self.when {
            Poll::Ready(())
        } else {
            // The duration has not elapsed, the future has not completed so
            // return `Poll::Pending`.
            //
            // The `Future` trait contract requires that when `Pending` is
            // returned, the future ensures that the given waker is signalled
            // once the future should be polled again. In our case, by
            // returning `Pending` here, we are promising that we will
            // invoke the given waker included in the `Context` argument
            // once the requested duration has elapsed. We ensure this by
            // spawning the timer thread above.
            //
            // If we forget to invoke the waker, the task will hang
            // indefinitely.
            Poll::Pending
        }
    }
}
#}</code></pre></pre>
<p>这个改动并不大，主要的想法是，在每次调用 <code>Future::poll</code> 时检查参数的 <code>Waker</code> 是否与之前保存的一致，如果一致则不需要做任何处理，否则的话则需要将保存的 <code>Waker</code> 替换为新的那个。</p>
<a class="header" href="tokio/tutorial-indepth.html#notify-utility" id="notify-utility"><h3>Notify Utility</h3></a>
<p>我们示范了如何手动的使用 <code>Waker</code> 来实现 <code>Delay Future</code>，<code>Waker</code> 是 Rust 的异步机制实现的基础支撑，但一般情况下我们并不需要深入到如此底层的东西，比如说在实现 <code>Delay</code> 时可以使用 <code>async/await</code> 并借助 <code>tokio::sync::Notify</code> 工具来避免复杂的底层信息。该工具提供了基础的任务通知机制，该机制处理了关于 <code>Waker</code> 的细节，包括如何保障当前记录的 <code>Waker</code> 跟最新的一致。</p>
<p>使用 <code>Notify</code> 后我们的 <code>Delay</code> 实现看起来成了这样</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use tokio::sync::Notify;
use std::sync::Arc;
use std::time::{Duration, Instant};
use std::thread;

async fn delay(dur: Duration) {
  let when = Instant::now() + dur;
  let notify = Arc::new(Notify::new());
  let notify2 = notify.clone();
  
  thread::spawn(move || {
    let now = Instant::now();
    
    if now &lt; when {
      thread::sleep(when - now);
    }
    
    notify2.notify_one();
  });
  
  notify.notified().await;
}
#}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="tokio/tutorial-framing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="tokio/tutorial-select.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="tokio/tutorial-framing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="tokio/tutorial-select.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
